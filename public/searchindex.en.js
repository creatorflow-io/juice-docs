var relearn_searchindex = [
  {
    "breadcrumb": "Juice's documentation \u003e \rOther services \u003e \rAudit services",
    "content": "Quick access Fixed file upload issue Fixed middleware registration Added more AuditFilterOptions methods Handle aborted request Fixed file upload issue In the case when you are using multipart form data to upload files, the file section stream must be processed for upload first. Otherwise, it can cause the error Unexpected end of Stream…. So we have to move the collection of request form data after other middleware is processed to avoid the issue.\nFixed middleware registration Fixed an error that occurred when you registered AuditMiddleware with the IApplicationBuilder.UseAudit extension.\nAdded more AuditFilterOptions methods Merge: merge new filter entries if they do not already exist IsExists: check if the filter entry already exists Handle aborted request Added AuditFilterOptions.RequestAbortedStatusCode option to specify the status code when the request is aborted. Default value is 408 Request Timeout Handle aborted request to add AccessLog",
    "description": "Quick access Fixed file upload issue Fixed middleware registration Added more AuditFilterOptions methods Handle aborted request Fixed file upload issue In the case when you are using multipart form data to upload files, the file section stream must be processed for upload first. Otherwise, it can cause the error Unexpected end of Stream…. So we have to move the collection of request form data after other middleware is processed to avoid the issue.",
    "tags": [],
    "title": "What's New in Audit 7.0.3",
    "uri": "/other_services/audit/whatsnew/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rBackground service \u003e \rLogging",
    "content": "Quick access Fixed unexpected error on stopping Windows service Change scopes behavior Write log scopes to file Naming convention Configurable write interval SignalR logger provider File logger provider Fixed unexpected error on stopping Windows service Sometimes you may receive an error message when trying to stop a service on Windows because it cannot be stopped properly.\nChange scopes behavior You can now use JobState scope inside JobId, so there is two ways to use JobState\nOriginal usage (yes, it still works): string? state; // {Logging:File:Directory}/{ServiceDescription}/{JobId} - {JobDescription}.log using (_logger.BeginScope(new List\u003cKeyValuePair\u003cstring, object\u003e\u003e { new KeyValuePair\u003cstring, object\u003e(\"JobId\", JobId), new KeyValuePair\u003cstring, object\u003e(\"JobDescription\", JobDescription) })){ // job processing _logger.LogInformation(\"Begin invoke\"); state = await InvokeAsync(); } // {Logging:File:Directory}/{ServiceDescription}/{JobId} - {JobDescription}_{JobState}.log // {Logging:File:Directory}/{ServiceDescription}/{JobId} - {JobDescription}_{JobState} ({increased number}).log using (_logger.BeginScope(new List\u003cKeyValuePair\u003cstring, object\u003e\u003e { new KeyValuePair\u003cstring, object\u003e(\"JobId\", JobId), new KeyValuePair\u003cstring, object\u003e(\"JobDescription\", JobDescription), new KeyValuePair\u003cstring, object\u003e(\"JobState\", state) })){ // job is completed with state _logger.LogInformation(\"Invoke result: {0}\", state); } // scopes [\"Task\", \"Success\"] using (_logger.BeginScope(\"Task\")) using (_logger.BeginScope(\"Success\")) { _logger.LogInformation(\"Invoked\"); }\rNow it’s more natural: // {Logging:File:Directory}/{ServiceDescription}/{JobId} - {JobDescription}.log using (_logger.BeginScope(new List\u003cKeyValuePair\u003cstring, object\u003e\u003e { new KeyValuePair\u003cstring, object\u003e(\"JobId\", JobId), new KeyValuePair\u003cstring, object\u003e(\"JobDescription\", JobDescription) })){ // job processing _logger.LogInformation(\"Begin invoke\"); var state = await InvokeAsync(); // {Logging:File:Directory}/{ServiceDescription}/{JobId} - {JobDescription}_{JobState}.log // {Logging:File:Directory}/{ServiceDescription}/{JobId} - {JobDescription}_{JobState} ({increased number}).log using (_logger.BeginScope(new List\u003cKeyValuePair\u003cstring, object\u003e\u003e { new KeyValuePair\u003cstring, object\u003e(\"JobState\", state) })){ // job is completed with state _logger.LogInformation(\"Invoke result: {0}\", state); } } // scopes [\"Task\", \"Success\"] using (_logger.BeginScope(new string[]{\"Task\", \"Success\"})) { _logger.LogInformation(\"Invoked\"); }\rWrite log scopes to file Any log scopes specified by the string will be written to the log file. See Log scopes\nNaming convention Correcting directory patterns:\nUnnamed service: {Logging:File:Directory}/General/ Named service: {Logging:File:Directory}/{ServiceDescription}/ Correcting file name patterns:\nDefault: {yyyy_MM_dd-HHmm}.log Job: {JobId} - {JobDescription}.log Job has state: {JobId} - {JobDescription}_{JobState}.log Job has re-run: {JobId} - {JobDescription}_{JobState} ({increased number}).log Configurable write interval You can now configure the BufferTime to decide how long to buffer before log entries are written to the file\nSignalR logger provider Supported logging to SignalR hub here.",
    "description": "Quick access Fixed unexpected error on stopping Windows service Change scopes behavior Write log scopes to file Naming convention Configurable write interval SignalR logger provider File logger provider Fixed unexpected error on stopping Windows service Sometimes you may receive an error message when trying to stop a service on Windows because it cannot be stopped properly.\nChange scopes behavior You can now use JobState scope inside JobId, so there is two ways to use JobState",
    "tags": [],
    "title": "What's New in BgService Logging 7.0.3",
    "uri": "/bg_service/logging/whatsnew/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rOther services \u003e \rLogging",
    "content": "We moved logging extensions from BackgroundService project to new Logging project to maintain it in general. Quick access Fixed unexpected error on stopping Windows service Change scopes behavior Write log scopes to file Naming convention Configurable write interval SignalR logger provider DB logger provider File logger provider Fixed unexpected error on stopping Windows service Sometimes you may receive an error message when trying to stop a service on Windows because it cannot be stopped properly.\nChange scopes behavior You can now use OperationState scope inside TraceId, so there is two ways to use OperationState\nOriginal usage (yes, it still works): string? state; // {Logging:File:Directory}/{ServiceDescription}/{TraceId} - {Operation}.log using (_logger.BeginScope(new List\u003cKeyValuePair\u003cstring, object\u003e\u003e { new KeyValuePair\u003cstring, object\u003e(\"TraceId\", TraceId), new KeyValuePair\u003cstring, object\u003e(\"Operation\", Operation) })){ // job processing _logger.LogInformation(\"Begin invoke\"); state = await InvokeAsync(); } // {Logging:File:Directory}/{ServiceDescription}/{TraceId} - {Operation}_{OperationState}.log // {Logging:File:Directory}/{ServiceDescription}/{TraceId} - {Operation}_{OperationState} ({increased number}).log using (_logger.BeginScope(new List\u003cKeyValuePair\u003cstring, object\u003e\u003e { new KeyValuePair\u003cstring, object\u003e(\"TraceId\", TraceId), new KeyValuePair\u003cstring, object\u003e(\"Operation\", Operation), new KeyValuePair\u003cstring, object\u003e(\"OperationState\", state) })){ // job is completed with state _logger.LogInformation(\"Invoke result: {0}\", state); } // scopes [\"Task\", \"Success\"] using (_logger.BeginScope(\"Task\")) using (_logger.BeginScope(\"Success\")) { _logger.LogInformation(\"Invoked\"); }\rNow it’s more natural: // {Logging:File:Directory}/{ServiceDescription}/{TraceId} - {Operation}.log using (_logger.BeginScope(new List\u003cKeyValuePair\u003cstring, object\u003e\u003e { new KeyValuePair\u003cstring, object\u003e(\"TraceId\", TraceId), new KeyValuePair\u003cstring, object\u003e(\"Operation\", Operation) })){ // job processing _logger.LogInformation(\"Begin invoke\"); var state = await InvokeAsync(); // {Logging:File:Directory}/{ServiceDescription}/{TraceId} - {Operation}_{OperationState}.log // {Logging:File:Directory}/{ServiceDescription}/{TraceId} - {Operation}_{OperationState} ({increased number}).log using (_logger.BeginScope(new List\u003cKeyValuePair\u003cstring, object\u003e\u003e { new KeyValuePair\u003cstring, object\u003e(\"OperationState\", state) })){ // job is completed with state _logger.LogInformation(\"Invoke result: {0}\", state); } } // scopes [\"Task\", \"Success\"] using (_logger.BeginScope(new string[]{\"Task\", \"Success\"})) { _logger.LogInformation(\"Invoked\"); }\rWrite log scopes to file Any log scopes specified by the string will be written to the log file. See Log scopes\nNaming convention Correcting directory patterns:\nUnnamed service: {Logging:File:Directory}/General/ Named service: {Logging:File:Directory}/{ServiceDescription}/ Correcting file name patterns:\nDefault: {yyyy_MM_dd-HHmm}.log Job: {TraceId} - {Operation}.log Job has state: {TraceId} - {Operation}_{OperationState}.log Job has re-run: {TraceId} - {Operation}_{OperationState} ({increased number}).log Configurable write interval You can now configure the BufferTime to decide how long to buffer before log entries are written to the file\nSignalR logger provider Supported logging to SignalR hub here.\nDb logger provider Supported logging to SignalR hub here.",
    "description": "We moved logging extensions from BackgroundService project to new Logging project to maintain it in general. Quick access Fixed unexpected error on stopping Windows service Change scopes behavior Write log scopes to file Naming convention Configurable write interval SignalR logger provider DB logger provider File logger provider Fixed unexpected error on stopping Windows service Sometimes you may receive an error message when trying to stop a service on Windows because it cannot be stopped properly.",
    "tags": [],
    "title": "What's New in Logging 7.0.3",
    "uri": "/other_services/logging/whatsnew/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rQuickstarts",
    "content": "In this chapter, we are going to start using Juice to build applications following these patterns:\nMicroservice with DDD/CQRS pattern Monolithic modular application However, if we have a reasonable approach, both of them may have the same structure and implementations but are different in the final target. So we will consider the following similar components (equivalent to separate sub-projects) before returning to focus on the patterns above.\nDomain Infrastructure Api Please follow up Layers in DDD microservices for more information and be careful when considering using the DDD and/or CQRS pattern. The directory tree will look like this:\n|-- src | |-- {namespace}.{feature} // Juice.Example(.Domain) | |-- {namespace}.{feature}.{infrastructure} // Juice.Example.EF | |-- {namespace}.{feature}.Api.Contracts // Juice.Example.Api.Contracts | |-- {namespace}.{feature}.Api // Juice.Example.Api | |-- {namespace}.{feature}.App // Juice.Example.App (target Microservice) | |-- {namespace}.{feature}.Module // Juice.Example.Module (target Monolithic modular) | |-- {namespace}.{feature}.Extensions.{extension} // optional |-- test | |-- {namespace}.{feature}.Test // Juice.Example.Test",
    "description": "In this chapter, we are going to start using Juice to build applications following these patterns:\nMicroservice with DDD/CQRS pattern Monolithic modular application However, if we have a reasonable approach, both of them may have the same structure and implementations but are different in the final target. So we will consider the following similar components (equivalent to separate sub-projects) before returning to focus on the patterns above.\nDomain Infrastructure Api Please follow up Layers in DDD microservices for more information and be careful when considering using the DDD and/or CQRS pattern. The directory tree will look like this:",
    "tags": [],
    "title": "Overview",
    "uri": "/quickstart/overview/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rCore features \u003e \rxUnit",
    "content": "To run complex unit tests with a full dependency injection pattern, we provide a simple DependencyResolver.\nusing Juice.Extensions.DependencyInjection; ... var resolver = new DependencyResolver { CurrentDirectory = AppContext.BaseDirectory }; resolver.ConfigureServices(services =\u003e { var configService = services.BuildServiceProvider().GetRequiredService\u003cIConfigurationService\u003e(); // IConfigurationRoot var configuration = configService.GetConfiguration(args); // configure options // register services }); // access IServiceProvider var serviceProvider = resolver.ServiceProvider;\rThe library can be accessed via Nuget:\nJuice",
    "description": "To run complex unit tests with a full dependency injection pattern, we provide a simple DependencyResolver.\nusing Juice.Extensions.DependencyInjection; ... var resolver = new DependencyResolver { CurrentDirectory = AppContext.BaseDirectory }; resolver.ConfigureServices(services =\u003e { var configService = services.BuildServiceProvider().GetRequiredService\u003cIConfigurationService\u003e(); // IConfigurationRoot var configuration = configService.GetConfiguration(args); // configure options // register services }); // access IServiceProvider var serviceProvider = resolver.ServiceProvider;\rThe library can be accessed via Nuget:",
    "tags": [],
    "title": "Dependency Injection",
    "uri": "/core/xunit/di/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rOther services",
    "content": "Versions\rlatest\r7.0.2\rQuick access File logger SignalR logger Db logger File logger provider Purposes Separate log folder for services Limit log file size Limit the number of log files Separate log file for job Usage Configure log builder Call AddFileLogger() on the logging builder to add a customized file logger provider.\nusing Juice.Extensions.Logging; ... var builder = WebApplication.CreateBuilder(args); builder.Logging.AddFileLogger(builder.Configuration.GetSection(\"Logging:File\"));\rLogging:File configuration section may be present:\nDirectory: where to store logging files RetainPolicyFileCount: default value is 50 MaxFileSize: default value is 5 * 1024 * 1024; ForkJobLog: default value is true BufferTime: the log entries will be written to the file after the interval (5 seconds by default) GeneralName: the default name of sub-directory if there is no ServiceDescription provided. It’s optional and the default value is General // appsettings.json { \"Logging\": { \"File\": { \"Directory\": \"C:\\\\Workspace\\\\Services\\\\logs\", \"BufferTime\": \"00:00:03\", //\"ForkJobLog\": false } } }\rSeparate logs by scopes To separate logs folder, we will init new log scope with specified properties:\nServiceId: Guid value ServiceDescription: string value You may want to store _logScope to dispose it later.\n// {Logging:File:Directory}/{ServiceDescription}/{yyyy_MM_dd-HHmm}.log _logScope = _logger.BeginScope(new List\u003cKeyValuePair\u003cstring, object\u003e\u003e { new KeyValuePair\u003cstring, object\u003e(\"ServiceId\", Id), new KeyValuePair\u003cstring, object\u003e(\"ServiceDescription\", Description) });\rTo separate log file for job, we will init new log scope with specified properties:\nTraceId: string value Operation: string value // {Logging:File:Directory}/{ServiceDescription}/{TraceId} - {Operation}.log using (_logger.BeginScope(new List\u003cKeyValuePair\u003cstring, object\u003e\u003e { new KeyValuePair\u003cstring, object\u003e(\"TraceId\", TraceId), new KeyValuePair\u003cstring, object\u003e(\"Operation\", Operation) })){ // job processing _logger.LogInformation(\"Begin invoke\"); var state = await InvokeAsync(); // {Logging:File:Directory}/{ServiceDescription}/{TraceId} - {Operation}_{OperationState}.log // {Logging:File:Directory}/{ServiceDescription}/{TraceId} - {Operation}_{OperationState} ({increased number}).log using (_logger.BeginScope(new List\u003cKeyValuePair\u003cstring, object\u003e\u003e { new KeyValuePair\u003cstring, object\u003e(\"OperationState\", state) })){ // job is completed with state _logger.LogInformation(\"Invoke result: {0}\", state); } }\rWrite log scopes to file Any log scopes specified by the string will be written to the log file\nusing (logger.BeginScope(\"Scope 1\")){ using(logger.BeginScope(\"Scope 1.1\")){ logger.LogInformation(\"Log inside scope\"); } } logger.LogInformation(\"Log outside scope\"); //---- Begin: Scope 1 //-------- Begin: Scope 1.1 // //{Timestamp} {LogLevel}: Log inside scope // //-------- End: Scope 1.1 //---- End: Scope 1 //{Timestamp} {LogLevel}: Log outside scope\rThe library can be accessed via Nuget:\nJuice.Extensions.Logging.File SignalR logger provider Purposes Send logs to signalR hub Log channel by ServiceId Support log State, Contextual and Scopes Usage Configure log builder Call AddSignalRLogger() on the logging builder to add a customized file logger provider.\nusing Juice.Extensions.Logging; ... var builder = WebApplication.CreateBuilder(args); builder.Logging.AddSignalRLogger(builder.Configuration.GetSection(\"Logging:SignalR\"));\rLogging:SignalR configuration section may be present:\nDirectory: where to store logging files for the SignalRLogger itself and the HubConnection RetainPolicyFileCount: default value is 50 MaxFileSize: default value is 5 * 1024 * 1024; BufferTime: the log entries will be written to the file after the interval (5 seconds by default) GeneralName: the sub-directory name to store logging files. It’s optional and the default value is SignalRLogger and SignalRLoggerHubConnection HubUrl: the signalR hub’s url JoinGroupMethod: optional method name to join group with ServiceId, default value is JoinGroup LogMethod: optional method name to send the log data, default value is LoggingAsync StateMethod: optional method name to send the state, default value is StateAsync ScopesSupported: hub is supported scopes logging or not ExcludedScopes: excluded scopes to send to the client. We will exclude ServiceId, ServiceDescription, TraceId, OperationState, Contextual by default, you can override this default by implementing IScopesFilter yourself Disabled: soft disable this logging channel // appsettings.json { \"Logging\": { \"File\": { \"Directory\": \"C:\\\\Workspace\\\\Services\\\\logs\", \"HubUrl\": \"https://localhost:57754/loghub\" } } }\rUsing logs scopes Basically, the supported scopes are like the File logger provider above, but SignalR logger provider is support more stronger named scopes:\nContextual: make it possible for your logging client to specify log colors by contextual. Ex: success, warning, danger… OperationState: if specified, we will send to the StateAsync method on the hub Any log scopes specified by the string will be sent to the log hub if it is supported.\nusing (_logger.BeginScope(new List\u003cKeyValuePair\u003cstring, object\u003e\u003e { new KeyValuePair\u003cstring, object\u003e(\"TraceId\", jobId), new KeyValuePair\u003cstring, object\u003e(\"Operation\", \"Invoke recurring tasks\") })) { // will send scopes [] _logger.LogInformation(\"Starting...\"); for (var i = 0; i \u003c 10; i++) { if (_stopRequest!.IsCancellationRequested) { break; } using (_logger.BeginScope($\"Task {i}\")) { // will send scopes [\"Task {i}\"] for (var j = 0; j \u003c 10; j++) { _logger.LogInformation(\"Processing {subtask}\", j); using (_logger.BeginScope(new List\u003cKeyValuePair\u003cstring, object\u003e\u003e { new KeyValuePair\u003cstring, object\u003e(\"Contextual\", \"success\") })) { _logger.LogError(\"Subtask {task} completed\", j); } } using (_logger.BeginScope(\"Succeeded\")) { // will send scopes [\"Task {i}\", \"Succeeded\"] _logger.LogInformation(\"Task {task} succeeded\", i); } } } using (_logger.BeginScope(new List\u003cKeyValuePair\u003cstring, object\u003e\u003e { new KeyValuePair\u003cstring, object\u003e(\"OperationState\", \"Succeeded\") })) { // will send to the state method, not logging method _logger.LogInformation(\"End\"); } }\rHub implementation The code block below is an example of signalR hub to handle logging\npublic class LogHub : Hub\u003cILogClient\u003e { public async Task LoggingAsync(Guid serviceId, string? traceId, string category, string message, LogLevel level, string? contextual, object[] scopes) { await Clients.Others.LoggingAsync(serviceId, traceId, category, message, level, contextual, scopes); } public async Task StateAsync(Guid serviceId, string? traceId, string state, string message) { await Clients.Others.StateAsync(serviceId, traceId, state, message); } public async Task BeginScopeAsync(Guid serviceId, string? traceId, string category, object scope) { await Clients.Others.BeginScopeAsync(serviceId, traceId, category, scope); } public async Task EndScopeAsync(Guid serviceId, string? traceId, string category, object scope) { await Clients.Others.EndScopeAsync(serviceId, traceId, category, scope); } }\rImplement IScopesFilter To custom the log scopes filter to send to SingalR client, you can implement the IScopesFilter and register it with DI\n// CustomScopesFilter.cs using Microsoft.Extensions.Options; internal class CustomScopesFilter : IScopesFilter{ public bool IsIncluded(string scope) { // your filter } }\r// Program.cs using Juice.Extensions.Logging; builder.Logging.AddSignalRLogger\u003cCustomScopesFilter\u003e(builder.Configuration.GetSection(\"Logging:SignalR\"));\rNOTE\nIf you are not supported for scopes in the logging method, please set the ScopesSupported to False The library can be accessed via Nuget:\nJuice.Extensions.Logging.SignalR DB logger provider Purposes Store log records to the DB, included ServiceId, TraceId and Operation Store log metrics by Service, Operation and Category to the DB Usage Call AddDbLogger() and/or AddMetricsLogger() on the logging builder to add a customized file logger provider.\nusing Juice.Extensions.Logging; ... var builder = WebApplication.CreateBuilder(args); // require RootConfiguration to access the ConnectionStrings builder.Logging.AddDbLogger(builder.Configuration.GetSection(\"Logging:Db\"), builder.Configuration); builder.Logging.AddMetricsLogger(builder.Configuration.GetSection(\"Logging:Metrics\"), builder.Configuration);\rLogging:Db configuration section may be present:\nDirectory: where to store logging files for the DbLogger itself RetainPolicyFileCount: default value is 50 MaxFileSize: default value is 5 * 1024 * 1024; BufferTime: the log entries will be written to the DB after the interval (5 seconds by default) GeneralName: the sub-directory name to store logging files. It’s optional and the default value is DBLogger DatabaseProvider: the database provider name Schema: the DB schema to create the log table ConnectionName: the DB connection name Disabled: soft disable this logging channel Logging:Metrics configuration section is as same as the Logging:Db but added:\nSampleRate: the sample rate to collect the log metrics, if not set, the collection time is 5 seconds. // appsettings.json { \"Logging\": { \"Db\": { \"Directory\": \"C:\\\\Workspace\\\\Services\\\\logs\", \"DatabaseProvider\": \"PostgreSQL\", \"LogLevel\": { \"Default\": \"Warning\" } }, \"Metrics\": { \"Directory\": \"C:\\\\Workspace\\\\Services\\\\logs\", \"DatabaseProvider\": \"PostgreSQL\", \"SampleRate\": \"00:00:30\", \"LogLevel\": { \"Default\": \"Information\" } } } }\rThe library can be accessed via Nuget:\nJuice.Extensions.Logging.EF Juice.Extensions.Logging.EF.PostgreSQL Juice.Extensions.Logging.EF.SqlServer",
    "description": "Versions\rlatest\r7.0.2\rQuick access File logger SignalR logger Db logger File logger provider Purposes Separate log folder for services Limit log file size Limit the number of log files Separate log file for job Usage Configure log builder Call AddFileLogger() on the logging builder to add a customized file logger provider.",
    "tags": [],
    "title": "Logging",
    "uri": "/other_services/logging/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rOther services",
    "content": "Versions\rlatest\r7.0.2\rQuick access Data audit Configure entity model Implement an auditable DbContext Handle DataEvent Default audit service Core concept Usage Configuration Programming API Data audit We already have a data audit framework based on EF Core and fully implemented in the DbContextBase abstract class. It will send a DataEvent via MediatR’s notification, the object contains:\nName: type of change (Inserted/ Modified/ Deleted) AuditRecord: contains all needed data audit information (User, Database, Schema, Table, KeyValues, OriginalValues, CurrentValues) What will you do? Configure entity model Only entities marked as auditable will have audit events triggeredd on their changes. You can mark an entity as auditable by two ways:\nInherit from IAuditable interface Call IsAuditable() on EntityTypeBuilder for your entity public class SampleEntity: IAuditable{ } // OR // Inside DbContext protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity\u003cSampleEntity\u003e(entity =\u003e { ... entity.IsAuditable(); ... }); }\rImplement an auditable DbContext If your DbContext inherits from the abstract class DbContextBase, please bypass this step. But if you want to implement a DbContext yourself, it must inherit IAuditableDbContext interface and you can follow these steps to configure:\nConfigureServices: we need User info and IMediator service to function.\nIf you are using pooled DbContext, your DbContext’s constructor must clean, it must contains only DbContextOptions argurment. So we will use PooledDbContextFactory pattern and implement a factory that inherit IDbContextFactory and call ConfigureServices() inside. // Dependency injection services.AddPooledDbContextFactory\u003cSampleDbContext\u003e(); services.AddScoped\u003cSampleDbContextScopedFactory\u003e(); services.AddScoped(sp =\u003e sp.GetRequiredService\u003cSampleDbContextScopedFactory\u003e().CreateDbContext());\r// Factory public class SampleDbContextScopedFactory : IDbContextFactory\u003cSampleDbContext\u003e { private readonly IDbContextFactory\u003cSampleDbContext\u003e _pooledFactory; private readonly IServiceProvider _serviceProvider; public SampleDbContextScopedFactory( IDbContextFactory\u003cSampleDbContext\u003e pooledFactory, IServiceProvider serviceProvider) { _pooledFactory = pooledFactory; _serviceProvider = serviceProvider; } public SampleDbContext CreateDbContext() { var context = _pooledFactory.CreateDbContext(); context.ConfigureServices(_serviceProvider); return context; } }\rOtherwise, we can call ConfigureServices() in DbContext’s constructor directly. Configure model to mark auditable entities.\nCall modelBuilder.ConfigureAuditableEntities() inside OnModelCreating(ModelBuilder modelBuilder) to mark all entities that inherit IAuditable as auditable. Call IsAuditable() on EntityTypeBuilder for your entity (step 1). Store the audit information before you SaveChanges and finally dispatch data change events.\nThe code block below is an example for an auditable DbContext.\npublic class SampleDbContext : DbContext, IAuditableDbContext { #region Auditable context public string? User { get; protected set; } private IHttpContextAccessor? _httpContextAccessor; public List\u003cAuditEntry\u003e? PendingAuditEntries { get; protected set; } #endregion protected IMediator? _mediator; protected ILogger? _logger; protected DbOptions? _options; /// \u003csummary\u003e /// Please call \u003cc\u003eConfigureServices(IServiceProvider serviceProvider)\u003c/c\u003e directly in your constructor /// or inside \u003cc\u003eIDbContextFactory.CreateDbContext()\u003c/c\u003e if you are using PooledDbContextFactory\u003c/para\u003e /// to init internal services\u003c/para\u003e /// \u003c/summary\u003e /// \u003cparam name=\"options\"\u003e\u003c/param\u003e public SampleDbContext(DbContextOptions options) : base(options) { } public virtual void ConfigureServices(IServiceProvider serviceProvider) { // Get user from HttpContext var httpContextAccessor = serviceProvider.GetService\u003cIHttpContextAccessor\u003e(); User = httpContextAccessor?.HttpContext?.User?.FindFirst(ClaimTypes.Name)?.Value; try { _mediator = serviceProvider.GetService\u003cIMediator\u003e(); } catch (Exception ex) { } } protected override void OnModelCreating(ModelBuilder modelBuilder) { base.OnModelCreating(modelBuilder); // Mark all entities that inherit IAuditable as auditable modelBuilder.ConfigureAuditableEntities(); // OR/ AND // Mark specified entities as auditable modelBuilder.Entity\u003cSampleEntity\u003e(entity =\u003e { ... entity.IsAuditable(); ... }); } private void ProcessingChanges() { if (PendingAuditEntries == null) { return; } _mediator.DispatchDataChangeEventsAsync(this).GetAwaiter().GetResult(); } public override async Task\u003cint\u003e SaveChangesAsync(bool acceptAllChangesOnSuccess, CancellationToken cancellationToken = default(CancellationToken)) { this.SetAuditInformation(_logger); PendingAuditEntries = _mediator != null ? this.TrackingChanges(_logger)?.ToList() : default; try { return await base.SaveChangesAsync(acceptAllChangesOnSuccess, cancellationToken); } finally { ProcessingChanges(); } } public override int SaveChanges(bool acceptAllChangesOnSuccess) { this.SetAuditInformation(_logger); PendingAuditEntries = _mediator != null ? this.TrackingChanges(_logger)?.ToList() : default; try { return base.SaveChanges(acceptAllChangesOnSuccess); } finally { ProcessingChanges(); } } }\rHandle DataEvent Implement your own handler by inheriting MediatR.INotificationHandler\u003cDataEvent\u003cT\u003e\u003e, so you can store anything you need proactively. Use default audit service that we provided below. Default audit service In this part, we provide not only data audit service but access logging service.\nCore concept AuditContext The AuditContext contains information about user access log, data audit entries. It will be initialized while a request is starting, be fulfilled while the request pipeline is invoking, and be committed by the IAuditService when the request pipeline is finished.\nIAuditContextAccessor The accessor to access AuditContext in the scope.\nIAuditService The service that processes the audited information to store or send it to other systems.\nAuditMiddleware The middleware that inits the AuditContext at the start of the request. It also collects the important information about the request:\nUser, DateTime, Action RequestInfo: RequestId, Headers, Host, Method, Path, RemoteIpAddress ServerInfo: MachineName, OSVersion, SoftwareVersion, AppName ResponseInfo: StatusCode, Headers, ElapsedMilliseconds. The Data was intended to be filled by other middleware that you will implement yourself. The Message, Error may be set by this middleware if an exception was thrown while invoking the next steps of the pipeline and there is no other middleware filling it. Otherwise, it may be filled by a custom middleware like the Data. It must be placed after Authentication middleware to have User information.\nNOTE: It often increases by 30ms - 70ms in request response time because saves the audit information with the EF repository or gRPC (tested with SQL Server and PostgreSQL on Docker, it depends on whether there are any DataAudit entries or not, and database provider).\nThe figure below is the request processing flow with AuditMiddleware injected.\nAudit process Usage We currently provide two ways to use the audit services.\nEF repository Use the AuditMiddleware to collect audit information and directly persist into the EF repository.\n// Minimal application Program.cs using Juice.Audit.AspNetCore.Extensions; ... var builder = WebApplication.CreateBuilder(args); // configure Audit services with default usage builder.Services.ConfigureAuditDefault(builder.Configuration, options =\u003e { // configure database options //options.DatabaseProvider = \"PostgreSQL\"; }); // MediatR service is required for Audit services builder.Services.AddMediatR(typeof(Program)); ... var app = builder.Build(); ... // if specified, the authentication middleware must place before the AuditMiddleware to have User info. // app.UseAuthentication(); // use AuditMiddleware to handle audit for specified request app.UseAudit(\"yourAppName\", options =\u003e { options.Include(\"\", \"GET\"); options.Exclude(\"/Index\"); });\rgRPC repository Use the AuditMiddleware to collect audit information and remotely persist to the audit server by gRPC.\nIn this usage, we will use ConfigureAuditGrpcClient() instead of ConfigureAuditDefault() for the application.\n// Minimal application Program.cs using Juice.Audit.AspNetCore.Extensions; ... var builder = WebApplication.CreateBuilder(args); // configure Audit services to use gRPC client builder.Services.ConfigureAuditGrpcClient(options =\u003e { options.Address = new Uri(\"https://localhost:7285\"); // the audit server endpoint // configure grpc client factory options options.ChannelOptionsActions.Add(o =\u003e { o.HttpHandler = new SocketsHttpHandler { PooledConnectionIdleTimeout = Timeout.InfiniteTimeSpan, KeepAlivePingDelay = TimeSpan.FromSeconds(60), KeepAlivePingTimeout = TimeSpan.FromSeconds(30), EnableMultipleHttp2Connections = true }; }); }); // MediatR service is required for Audit services builder.Services.AddMediatR(typeof(Program)); ... var app = builder.Build(); ... // if specified, the authentication middleware must place before the AuditMiddleware to have User info. // app.UseAuthentication(); // use AuditMiddleware to handle audit for specified request app.UseAudit(\"yourAppName\", options =\u003e { options.Include(\"\", \"GET\"); options.Exclude(\"/Index\"); });\rWe also need an audit server to handle the audit messages.\n// Audit server Program.cs using Juice.Audit.AspNetCore.Extensions; ... var builder = WebApplication.CreateBuilder(args); // configure Audit services as a server builder.Services.ConfigureAuditGrpcHost(builder.Configuration, options =\u003e { options.DatabaseProvider = \"PostgreSQL\"; }); // MediatR and Grpc services is required for Audit services builder.Services.AddMediatR(typeof(Program)); builder.Services.AddGrpc(o =\u003e o.EnableDetailedErrors = true); ... var app = builder.Build(); ... // map gPRC endpoint to handle audit messages app.MapAuditGrpcServer();\rPlease follow this link to read about rRPC performance tips.\nConfiguration EF repositories You can configure DbOptions to specify database provider, schema… See DbOptions for more information.\nAudit filters You can configure AuditFilterOptions to specify the paths and methods you want to audit, as well as request/response headers to store in the access log.\nPath and method filtering to processing You can describe multiple paths, zero or more methods per path. The path and method are case insensitive You can define a rule with specified priority and then add it to Filters or load the rule from configuration You can use * to describe a single segment You can use # to describe zero or more segments Response status filtering You can describe multiple response status codes so that AuditMiddleware will process the request upon completion The status codes described will be associated with the filter path at the same time Request/response headers filtering to store You can use * to describe a single segment You can use # to describe zero or more segments Request headers will be stored by default: :authority:, accept-#, content-*, x-forwarded-#, referer, user-agent Response headers will be stored by default: content-* Some main methods of AuditFilterOptions that help us build the filter options:\nClear: clear all existing filter entries Include: append a filter entry to include path, methods… Exclude: append a filter entry to exclude path, methods… Merge: merge new filter entries if they do not already exist IsExists: check if the filter entry already exists StoreEmptyRequestHeaders: clear all request header filters StoreRequestHeaders: add new request header filters StoreEmptyResponseHeaders: clear all response header filters StoreResponseHeaders: add new response header filters NOTE\nLeave blank (of Path, Methods, StatusCodes) will have the same meaning as any Rules added later by filter builder will have higher priority by default Rules added by configuration section will have the same priority level of 0 by default The code blocks below are two ways to configure the audit filter\n//Program.cs var configs = new AuditFilterOptions(); builder.Configuration.Bind(\"Audit\", configs); app.UseAudit(\"yourAppName\", options =\u003e { // describe the paths and methods to logging user acess and data audit options.Include(\"\", \"GET\"); // include any GET request options.Exclude(\"/Index\"); // exclude requests to /Index // include all POST, PUT request to the path that: // - starts with /kernel // - has one or more segment after // Ex: /kernel/foo, /kernel/foo/bar, /kernel/foo/bar/barbar ... options.Include(\"/kernel/*/#\", \"POST\", \"PUT\"); // merge filter entries from appsettings options.Merge(configs.Filters); // Only store the request headers like: accept, accept-encoding, accept-language-x, // content-type, content-length... but not content, content-type-y options.StoreEmptyRequestHeaders() .StoreRequestHeaders(\"accept-#\", \"content-*\"); });\r//appsettings.json \"Audit:Filters\": [ // path filter antries { \"Methods\": [ \"POST\", \"PUT\", \"DELETE\" ], \"Priority\": -1 }, { \"IsExcluded\": true, \"Path\": \"/#/negotiate\" }, { \"IsExcluded\": true, \"Path\": \"/error/*\" }, { \"StatusCodes\": [400, 500] } ]\rThe model presents the filter entry here\nclass PathFilterEntry { public int Priority { get; set; } = 0; public bool IsExcluded { get; set; } = false; public string Path { get; set; } = string.Empty; public string[] Methods { get; set; } = Array.Empty\u003cstring\u003e(); public int[] StatusCodes { get; set; } = Array.Empty\u003cint\u003e(); }\rProgramming API Fulfill response information The Data, Msg, Err of ResponseInfo can only be assigned values once. In AuditMiddleware, we do not try to set Data but rather Msg and Err by handling the pipeline call exception. To set Msg, Err, Data in other middlewares or action filter, we can use IAuditContextAccessor service to access the AuditContext and then try to set the response information.\nauditContextAccessor.AuditContext?.UpdateResponseInfo(response =\u003e { response.TrySetMessage(\"An useful message\"); response.TrySetData(\"{\\\"foo\\\":\\\"bar\\\"}\"); });\rAdd more audit entries By default, we use DataEvenNotificationtHandler to handle DataEvent and add DataAudit entries, but you can add DataAudit entries manually by access the AuditContext.\nauditContextAccessor.AuditContext?.AddAuditEntries(entry1, entry2...);\rAdditional metadata If the current audit information is not enough, you can add more information to the Metadata by access the AuditContext.\nauditContextAccessor.AuditContext?.AccessRecord?.SetMetadata(key, value); // OR auditContextAccessor.AuditContext?.AccessRecord?.SetMetadataJson(jsonString);\rThe library can be accessed via Nuget:\nJuice.Audit Juice.Audit.Api.Contracts Juice.Audit.Api Juice.Audit.EF Juice.Audit.EF.SqlServer Juice.Audit.EF.PostgreSQL",
    "description": "Versions\rlatest\r7.0.2\rQuick access Data audit Configure entity model Implement an auditable DbContext Handle DataEvent Default audit service Core concept Usage Configuration Programming API Data audit We already have a data audit framework based on EF Core and fully implemented in the DbContextBase abstract class. It will send a DataEvent via MediatR’s notification, the object contains:",
    "tags": [],
    "title": "Audit services",
    "uri": "/other_services/audit/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rCore features",
    "content": "In this chapter, we will look at common components and extensions:\nLogging Options Configuration Swagger MediatR Event bus Integration service Multi-tenant Audit XUnit Modular We implemented these extensions and services to resolved common problems that were specified in Application models section. To achieve more value out of this document, please go through .NET Microservices: Architecture for Containerized .NET Applications.\nNOTE: Juice is currently in beta, so you must select the Include prerelease checkbox in the Nuget packages window to browse its packages.",
    "description": "In this chapter, we will look at common components and extensions:\nLogging Options Configuration Swagger MediatR Event bus Integration service Multi-tenant Audit XUnit Modular We implemented these extensions and services to resolved common problems that were specified in Application models section. To achieve more value out of this document, please go through .NET Microservices: Architecture for Containerized .NET Applications.\nNOTE: Juice is currently in beta, so you must select the Include prerelease checkbox in the Nuget packages window to browse its packages.",
    "tags": [],
    "title": "Overview",
    "uri": "/core/overview/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rOverview",
    "content": "Most modern applications look similar like this: Your applications may have more or fewer components:\nThe service-bus may or may not be available You may choose single or multi-tenant model You can use local or remote authentication/authorization services So we wanted a simple codebase for beginners. It includes the following characteristics:\nSimple and easy to use, we can start with just what we need Lightweight: it must quick to start and work on low-memory environments Ready to integrate: it can work with third-party libraries without conflict Ready to use: it has some built-in services that we can use right away JUICE is not a complete framework. It cannot help you quickly build an app with less code but provides implementation of some extensions and small tools that you normally use to build your apps. It also contains examples of microservices for beginners.",
    "description": "Most modern applications look similar like this: Your applications may have more or fewer components:\nThe service-bus may or may not be available You may choose single or multi-tenant model You can use local or remote authentication/authorization services So we wanted a simple codebase for beginners. It includes the following characteristics:\nSimple and easy to use, we can start with just what we need Lightweight: it must quick to start and work on low-memory environments Ready to integrate: it can work with third-party libraries without conflict Ready to use: it has some built-in services that we can use right away JUICE is not a complete framework. It cannot help you quickly build an app with less code but provides implementation of some extensions and small tools that you normally use to build your apps. It also contains examples of microservices for beginners.",
    "tags": [],
    "title": "Purposes",
    "uri": "/overview/purpose/index.html"
  },
  {
    "breadcrumb": "Juice's documentation",
    "content": "Overview Purpose\nApplication models",
    "description": "Overview Purpose\nApplication models",
    "tags": [],
    "title": "Overview",
    "uri": "/overview/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rCore features \u003e \rEvent bus",
    "content": "Change RabbitMQ default behavior on handling failure From version 8.4.x, we added AckOnProcessed option in the RabbitMQOptions and change default behavior when IIntegrationEventHandler service found for incoming integration event but it throws an exception.\nBefore: the Nack message will be sent back to the broker, so the integration event will be processed repeatedly util it’s done. From 8.4.x: the Ack message will be sent back to the broker, so the integration event will be processed once, even if it fails. Tenant intended when publish message IEventBus now added tenantId parameter into PublishAsync method to supports multi-tenant.",
    "description": "Change RabbitMQ default behavior on handling failure From version 8.4.x, we added AckOnProcessed option in the RabbitMQOptions and change default behavior when IIntegrationEventHandler service found for incoming integration event but it throws an exception.\nBefore: the Nack message will be sent back to the broker, so the integration event will be processed repeatedly util it’s done. From 8.4.x: the Ack message will be sent back to the broker, so the integration event will be processed once, even if it fails. Tenant intended when publish message IEventBus now added tenantId parameter into PublishAsync method to supports multi-tenant.",
    "tags": [],
    "title": "Breaking changes",
    "uri": "/core/eventbus/breaking/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rCore features \u003e \rxUnit",
    "content": "Sometimes we want to show the app logs in unit tests for easier debugging. So TestOutputLoggerProvider can help us.\nusing Juice.Extensions.DependencyInjection; using Microsoft.Extensions.Logging; ... var builder = new DependencyResolver(); builder.ConfigureServices(services =\u003e { var configService = services.BuildServiceProvider().GetRequiredService\u003cIConfigurationService\u003e(); var configuration = configService.GetConfiguration(); services.AddLogging(builder =\u003e { builder.ClearProviders() .AddTestOutputLogger() .AddConfiguration(configuration.GetSection(\"Logging\")); }); // must register an instance of ITestOutputHelper services.AddSingleton(_output); // configure other services ... });\rThe library can be accessed via Nuget:\nJuice.XUnit",
    "description": "Sometimes we want to show the app logs in unit tests for easier debugging. So TestOutputLoggerProvider can help us.\nusing Juice.Extensions.DependencyInjection; using Microsoft.Extensions.Logging; ... var builder = new DependencyResolver(); builder.ConfigureServices(services =\u003e { var configService = services.BuildServiceProvider().GetRequiredService\u003cIConfigurationService\u003e(); var configuration = configService.GetConfiguration(); services.AddLogging(builder =\u003e { builder.ClearProviders() .AddTestOutputLogger() .AddConfiguration(configuration.GetSection(\"Logging\")); }); // must register an instance of ITestOutputHelper services.AddSingleton(_output); // configure other services ... });\rThe library can be accessed via Nuget:",
    "tags": [],
    "title": "Logging",
    "uri": "/core/xunit/logging/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rCore features \u003e \rLogging",
    "content": "Quick access ExternalScopeLoggerProvider Use ExternalScopeLoggerProvider to share scopes (since 7.0.3) The abstract class LoggerProvider should no longer inherit the interface ISupportExternalScope but use the ExternalScopeLoggerProvider instead.",
    "description": "Quick access ExternalScopeLoggerProvider Use ExternalScopeLoggerProvider to share scopes (since 7.0.3) The abstract class LoggerProvider should no longer inherit the interface ISupportExternalScope but use the ExternalScopeLoggerProvider instead.",
    "tags": [],
    "title": "Breaking changes",
    "uri": "/core/logging/breaking/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rOther services \u003e \rLogging",
    "content": "Quick access Moved file logging provider Default service name Moved file logging provider The FileLoggerProvider is not included in Juice.BgService.ServiceBase but moved to new Juice.Extensions.Logging.File package.\nDefault service name The default service name has been changed from Default to General, but it can be configured using the GeneralName option.\nChange the scope property name JobId changed to TraceId JobDescription changed to Operation JobState changed to OprationState",
    "description": "Quick access Moved file logging provider Default service name Moved file logging provider The FileLoggerProvider is not included in Juice.BgService.ServiceBase but moved to new Juice.Extensions.Logging.File package.\nDefault service name The default service name has been changed from Default to General, but it can be configured using the GeneralName option.\nChange the scope property name JobId changed to TraceId JobDescription changed to Operation JobState changed to OprationState",
    "tags": [],
    "title": "Breaking changes in Logging 7.0.3",
    "uri": "/other_services/logging/breaking/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rCore features",
    "content": "Versions\rlatest\r7.0.2\rThere are many great logging frameworks for .Net Core like Log4Net, SeriLog, NLog… However, if you wish to customize logging system for special purpose, then you can inherit the LoggerProvider abstract class:\npublic abstract class LoggerProvider : IDisposable, ILoggerProvider, ISupportExternalScope { ... public IExternalScopeProvider ScopeProvider { get; } /// \u003csummary\u003e /// Writes the specified log information to a log file. /// \u003c/summary\u003e public abstract void WriteLog\u003cTState\u003e(LogEntry\u003cTState\u003e entry, string formattedMessage); #region IDisposable Support /// \u003csummary\u003e /// Cleanup resources on disposing. /// \u003c/summary\u003e protected abstract void Cleanup(); ... #endregion }\rOnce you have an implementation, you can register it when you add logging:\nservices.AddLogging(builder =\u003e { builder.ClearProviders(); // optional builder.AddConfiguration(); // configure your options if needed // register service builder.Services.TryAddEnumerable( ServiceDescriptor.Singleton\u003cILoggerProvider, YourLoggerProvider\u003e()); });\rOr register to existing application logging builder:\nvar builder = WebApplication.CreateBuilder(args); // configure your options if needed // register service builder.Logging.Services.TryAddEnumerable( ServiceDescriptor.Singleton\u003cILoggerProvider, YourLoggerProvider\u003e());\rSee Logging extensions XUnit output logging for example.\nThe library can be accessed via Nuget:\nJuice.Extensions.Logging",
    "description": "Versions\rlatest\r7.0.2\rThere are many great logging frameworks for .Net Core like Log4Net, SeriLog, NLog… However, if you wish to customize logging system for special purpose, then you can inherit the LoggerProvider abstract class:",
    "tags": [],
    "title": "Logging",
    "uri": "/core/logging/index.html"
  },
  {
    "breadcrumb": "Juice's documentation",
    "content": "Quickstarts Domain\nInfrastructure\nAPI Contracts\nAPI\nMicroservice\nMonolithic",
    "description": "Quickstarts Domain\nInfrastructure\nAPI Contracts\nAPI\nMicroservice\nMonolithic",
    "tags": [],
    "title": "Quickstarts",
    "uri": "/quickstart/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rOverview",
    "content": "Monolithic If you are starting to build an application without any existing product reference or new products without an idea to start with, monolithic architecture may be a good fit. Be careful with microservices if you are not sure about your product’s size, how many users you have to serve or what specific services need to scale… because it can be complicated and unnecessary.\nThe most common problems when we deploy a monolithic application are:\nSynchronizing settings between servers. It can be done manually or configured centrally (via shared folder, shared DB…) Shared sessions between servers can be made easy by using distributed cache Distributed logs are hard to mine In most cases, we have to clone large application to scale out instead of components. It is time to separate components into microservices And in large applications, development also matters. Many developers will work independently but consistently, so we must split a big project into many sub-projects for features then use it as reference packages in final project. A modular model can be a good choice; all developers will register their services and configuration at module startup.\nMicroservices Sometimes we need to rebuild all dependent projects to ensure that their references have the same version and the final application will work. Whenever we have a small change, no one can guarantee that the change will work for other features. We only know when it happens and not during build time. So a small change can lead to a large app that must be tested. It can affect multiple teams at once instead of a specific team.\nBesides the problem of scaling the processing capacity of the monolithic application, we may need to scale up more human resources than necessary.\nMicroservices are needed when:\nYou need to scale up your system or part of it to serve more users You don’t have many people to maintain and develop the existing project or you have many people to start a new project and deliver on time You want to integrate with 3rd party or internal services easily Unfortunatelly, this model has even more problems that need to be resolved besides the traditional problems of monolithic app:\nNotifications between services require an external event bus instead of an internal bus. These integration events are added by the domain business follow and sent after the domain process success Integrated events may be duplicated lead to repeated event processing SaaS Now a day, SaaS is growing up quickly to help ICT companies can provide their products and services to many customers rapidly and easily. We can provice multi-tenant services using infrastructure, in-app implementation, or mixed mode.\nIn most cases, we need separte tenant configuration, data, and resources. So we have common problems:\nTenant identification Configuration/Option by tenant but centralized Data and resources can be either separated or shared between tenants How we can help Choose the development model according to actual needs and conditions. We provide several application template:\nMVC API Modular: register and work as a module in MVC and API app Microservice: work independently",
    "description": "Monolithic If you are starting to build an application without any existing product reference or new products without an idea to start with, monolithic architecture may be a good fit. Be careful with microservices if you are not sure about your product’s size, how many users you have to serve or what specific services need to scale… because it can be complicated and unnecessary.\nThe most common problems when we deploy a monolithic application are:",
    "tags": [],
    "title": "Application models",
    "uri": "/overview/app_model/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rQuickstarts",
    "content": "This layer will name {namespace}.{feature}.\nThe project tree will look like this:\n|-- Domain | |-- AggregrateModel | |-- AbcAggregrate | | Abc.cs | | IAbcRepository.cs // suggested | |-- XyzAggregrate | |-- Commands | |-- CreateAbcCommand.cs | |-- Events | |-- AbcCreatedDomainEvent.cs | |-- CommandHandlers // move it into API project if you are not implementing the Repository | |-- CreateAbcCommandHandler.cs // to handle create Abc command (as same as Manager) |-- DependencyInjection // optional | |-- YourServiceCollectionExtensions.cs // to register your services\rIn the tree above:\nAbc is an aggregarte model that implement IAggregrateRoot. using Juice.Domain; public class Abc: IAggregrateRoot\u003cINotification\u003e{ // INotification is an interface of MediatR public Abc() { } // parameterless constructor is needed for EF public Abc(string name, string correlationId) { Name = name; CorrelationId = correlationId; } [Key] public Guid Id { get; init; } public string Name { get; init; } public string CorrelationId { get; init; } public void UpdateName(string newName){ var originName = Name; // validation for new name then update it into Name ... // add a domain event to notice that name was changed this.AddDomainEvent(new AbcNameChangedDomainEvent(originName, newName)); } }\rIAbcRepository will define methods to CRUD Abc (and entities within its boundaries) and all you need. The Commands folder will contain commands to process specified use-cases. A command must contains: Identifier: to identify processing object Data: enough to process the use-case The CommandHandlers folder will contain classes to handle the commands above Use IAbcRepository to read domain objects by Identifier or init domain objects from the command’s data Call domain method to process the use-case Use IAbcRepository to persist data back to data backend",
    "description": "This layer will name {namespace}.{feature}.\nThe project tree will look like this:\n|-- Domain | |-- AggregrateModel | |-- AbcAggregrate | | Abc.cs | | IAbcRepository.cs // suggested | |-- XyzAggregrate | |-- Commands | |-- CreateAbcCommand.cs | |-- Events | |-- AbcCreatedDomainEvent.cs | |-- CommandHandlers // move it into API project if you are not implementing the Repository | |-- CreateAbcCommandHandler.cs // to handle create Abc command (as same as Manager) |-- DependencyInjection // optional | |-- YourServiceCollectionExtensions.cs // to register your services\rIn the tree above:",
    "tags": [],
    "title": "Domain",
    "uri": "/quickstart/domain/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rCore features \u003e \rxUnit",
    "content": "Here is an approach for in-order testing.\nFirst, we add the [TestCaseOrderer] attribute to the xUnit test class then add the [TestPriority] attribute to the test method. The test method with higher Priority will run first.\nusing Juice.XUnit; [TestCaseOrderer(\"Juice.XUnit.PriorityOrderer\", \"Juice.XUnit\")] public class EFTest { [Fact(TestPriority(99)] public async Task Shoud_run_first() { } [Fact(TestPriority(98)] public async Task Shoud_run_second() { } }\rThe library can be accessed via Nuget:\nJuice.XUnit",
    "description": "Here is an approach for in-order testing.\nFirst, we add the [TestCaseOrderer] attribute to the xUnit test class then add the [TestPriority] attribute to the test method. The test method with higher Priority will run first.\nusing Juice.XUnit; [TestCaseOrderer(\"Juice.XUnit.PriorityOrderer\", \"Juice.XUnit\")] public class EFTest { [Fact(TestPriority(99)] public async Task Shoud_run_first() { } [Fact(TestPriority(98)] public async Task Shoud_run_second() { } }\rThe library can be accessed via Nuget:",
    "tags": [],
    "title": "Priority",
    "uri": "/core/xunit/priority/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rBackground service \u003e \rLogging",
    "content": "Versions\rlatest\r7.0.2\rPurposes Separate log folder for services Limit log file size Limit the number of log files Separate log file for job Usage Configure log builder Call AddBgServiceFileLogger() on the logging builder to add a custom file logger provider. using Juice.BgService.Extensions.Logging; ... var builder = WebApplication.CreateBuilder(args); builder.Logging.AddBgServiceFileLogger(builder.Configuration.GetSection(\"Logging:File\"));\rLogging:File configuration section may be present:\nDirectory RetainPolicyFileCount: default value is 50 MaxFileSize: default value is 5 * 1024 * 1024; ForkJobLog: default value is true Separate logs by scope To separate logs folder, we will init new log scope with specified properties:\nServiceId: Guid value ServiceDescription: string value You may want to store _logScope to dispose it later.\n// {Logging:File:Directory}/{ServiceDescription}/{yyyy_MM_dd-HHmm}.log _logScope = _logger.BeginScope(new List\u003cKeyValuePair\u003cstring, object\u003e\u003e { new KeyValuePair\u003cstring, object\u003e(\"ServiceId\", Id), new KeyValuePair\u003cstring, object\u003e(\"ServiceDescription\", Description) });\rTo separate log file for job, we will init new log scope with specified properties:\nJobId: string value JobDescription: string value // {Logging:File:Directory}/{ServiceDescription}/{JobId} - {JobDescription}.log using (_logger.BeginScope(new List\u003cKeyValuePair\u003cstring, object\u003e\u003e { new KeyValuePair\u003cstring, object\u003e(\"JobId\", JobId), new KeyValuePair\u003cstring, object\u003e(\"JobDescription\", JobDescription) })){ // job processing } // {Logging:File:Directory}/{ServiceDescription}/{JobId} - {JobDescription}_{JobState}.log // {Logging:File:Directory}/{ServiceDescription}/{JobId} - {JobDescription}_{JobState} (attempted).log using (_logger.BeginScope(new List\u003cKeyValuePair\u003cstring, object\u003e\u003e { new KeyValuePair\u003cstring, object\u003e(\"JobId\", JobId), new KeyValuePair\u003cstring, object\u003e(\"JobDescription\", JobDescription), new KeyValuePair\u003cstring, object\u003e(\"JobState\", JobState) })){ // job is completed with state }",
    "description": "Versions\rlatest\r7.0.2\rPurposes Separate log folder for services Limit log file size Limit the number of log files Separate log file for job Usage Configure log builder Call AddBgServiceFileLogger() on the logging builder to add a custom file logger provider. using Juice.BgService.Extensions.Logging; ... var builder = WebApplication.CreateBuilder(args); builder.Logging.AddBgServiceFileLogger(builder.Configuration.GetSection(\"Logging:File\"));\rLogging:File configuration section may be present:",
    "tags": [],
    "title": "Logging",
    "uri": "/bg_service/logging/v7.0.2/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rOther services \u003e \rLogging",
    "content": "Versions\rlatest\r7.0.2\rThis is original doc of BgService Logging but now moved to new project.\nPurposes Separate log folder for services Limit log file size Limit the number of log files Separate log file for job Usage Configure log builder Call AddBgServiceFileLogger() on the logging builder to add a custom file logger provider. using Juice.BgService.Extensions.Logging; ... var builder = WebApplication.CreateBuilder(args); builder.Logging.AddBgServiceFileLogger(builder.Configuration.GetSection(\"Logging:File\"));\rLogging:File configuration section may be present:\nDirectory RetainPolicyFileCount: default value is 50 MaxFileSize: default value is 5 * 1024 * 1024; ForkJobLog: default value is true Separate logs by scope To separate logs folder, we will init new log scope with specified properties:\nServiceId: Guid value ServiceDescription: string value You may want to store _logScope to dispose it later.\n// {Logging:File:Directory}/{ServiceDescription}/{yyyy_MM_dd-HHmm}.log _logScope = _logger.BeginScope(new List\u003cKeyValuePair\u003cstring, object\u003e\u003e { new KeyValuePair\u003cstring, object\u003e(\"ServiceId\", Id), new KeyValuePair\u003cstring, object\u003e(\"ServiceDescription\", Description) });\rTo separate log file for job, we will init new log scope with specified properties:\nJobId: string value JobDescription: string value // {Logging:File:Directory}/{ServiceDescription}/{JobId} - {JobDescription}.log using (_logger.BeginScope(new List\u003cKeyValuePair\u003cstring, object\u003e\u003e { new KeyValuePair\u003cstring, object\u003e(\"JobId\", JobId), new KeyValuePair\u003cstring, object\u003e(\"JobDescription\", JobDescription) })){ // job processing } // {Logging:File:Directory}/{ServiceDescription}/{JobId} - {JobDescription}_{JobState}.log // {Logging:File:Directory}/{ServiceDescription}/{JobId} - {JobDescription}_{JobState} (attempted).log using (_logger.BeginScope(new List\u003cKeyValuePair\u003cstring, object\u003e\u003e { new KeyValuePair\u003cstring, object\u003e(\"JobId\", JobId), new KeyValuePair\u003cstring, object\u003e(\"JobDescription\", JobDescription), new KeyValuePair\u003cstring, object\u003e(\"JobState\", JobState) })){ // job is completed with state }",
    "description": "Versions\rlatest\r7.0.2\rThis is original doc of BgService Logging but now moved to new project.\nPurposes Separate log folder for services Limit log file size Limit the number of log files Separate log file for job Usage Configure log builder Call AddBgServiceFileLogger() on the logging builder to add a custom file logger provider. using Juice.BgService.Extensions.Logging; ... var builder = WebApplication.CreateBuilder(args); builder.Logging.AddBgServiceFileLogger(builder.Configuration.GetSection(\"Logging:File\"));\rLogging:File configuration section may be present:",
    "tags": [],
    "title": "Logging",
    "uri": "/other_services/logging/v7.0.2/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rOther services \u003e \rAudit services",
    "content": "Versions\rlatest\r7.0.2\rQuick access Data audit Configure entity model Implement an auditable DbContext Handle DataEvent Default audit service Core concept Usage Configuration Programming API Data audit We already have a data audit framework based on EF Core and fully implemented in the DbContextBase abstract class. It will send a DataEvent via MediatR’s notification, the object contains:\nName: type of change (Inserted/ Modified/ Deleted) AuditRecord: contains all needed data audit information (User, Database, Schema, Table, KeyValues, OriginalValues, CurrentValues) What will you do? Configure entity model Only entities marked as auditable will have audit events triggeredd on their changes. You can mark an entity as auditable by two ways:\nInherit from IAuditable interface Call IsAuditable() on EntityTypeBuilder for your entity public class SampleEntity: IAuditable{ } // OR // Inside DbContext protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity\u003cSampleEntity\u003e(entity =\u003e { ... entity.IsAuditable(); ... }); }\rImplement an auditable DbContext If your DbContext inherits from the abstract class DbContextBase, please bypass this step. But if you want to implement a DbContext yourself, it must inherit IAuditableDbContext interface and you can follow these steps to configure:\nConfigureServices: we need User info and IMediator service to function.\nIf you are using pooled DbContext, your DbContext’s constructor must clean, it must contains only DbContextOptions argurment. So we will use PooledDbContextFactory pattern and implement a factory that inherit IDbContextFactory and call ConfigureServices() inside. // Dependency injection services.AddPooledDbContextFactory\u003cSampleDbContext\u003e(); services.AddScoped\u003cSampleDbContextScopedFactory\u003e(); services.AddScoped(sp =\u003e sp.GetRequiredService\u003cSampleDbContextScopedFactory\u003e().CreateDbContext());\r// Factory public class SampleDbContextScopedFactory : IDbContextFactory\u003cSampleDbContext\u003e { private readonly IDbContextFactory\u003cSampleDbContext\u003e _pooledFactory; private readonly IServiceProvider _serviceProvider; public SampleDbContextScopedFactory( IDbContextFactory\u003cSampleDbContext\u003e pooledFactory, IServiceProvider serviceProvider) { _pooledFactory = pooledFactory; _serviceProvider = serviceProvider; } public SampleDbContext CreateDbContext() { var context = _pooledFactory.CreateDbContext(); context.ConfigureServices(_serviceProvider); return context; } }\rOtherwise, we can call ConfigureServices() in DbContext’s constructor directly. Configure model to mark auditable entities.\nCall modelBuilder.ConfigureAuditableEntities() inside OnModelCreating(ModelBuilder modelBuilder) to mark all entities that inherit IAuditable as auditable. Call IsAuditable() on EntityTypeBuilder for your entity (step 1). Store the audit information before you SaveChanges and finally dispatch data change events.\nThe code block below is an example for an auditable DbContext.\npublic class SampleDbContext : DbContext, IAuditableDbContext { #region Auditable context public string? User { get; protected set; } private IHttpContextAccessor? _httpContextAccessor; public List\u003cAuditEntry\u003e? PendingAuditEntries { get; protected set; } #endregion protected IMediator? _mediator; protected ILogger? _logger; protected DbOptions? _options; /// \u003csummary\u003e /// Please call \u003cc\u003eConfigureServices(IServiceProvider serviceProvider)\u003c/c\u003e directly in your constructor /// or inside \u003cc\u003eIDbContextFactory.CreateDbContext()\u003c/c\u003e if you are using PooledDbContextFactory\u003c/para\u003e /// to init internal services\u003c/para\u003e /// \u003c/summary\u003e /// \u003cparam name=\"options\"\u003e\u003c/param\u003e public SampleDbContext(DbContextOptions options) : base(options) { } public virtual void ConfigureServices(IServiceProvider serviceProvider) { // Get user from HttpContext var httpContextAccessor = serviceProvider.GetService\u003cIHttpContextAccessor\u003e(); User = httpContextAccessor?.HttpContext?.User?.FindFirst(ClaimTypes.Name)?.Value; try { _mediator = serviceProvider.GetService\u003cIMediator\u003e(); } catch (Exception ex) { } } protected override void OnModelCreating(ModelBuilder modelBuilder) { base.OnModelCreating(modelBuilder); // Mark all entities that inherit IAuditable as auditable modelBuilder.ConfigureAuditableEntities(); // OR/ AND // Mark specified entities as auditable modelBuilder.Entity\u003cSampleEntity\u003e(entity =\u003e { ... entity.IsAuditable(); ... }); } private void ProcessingChanges() { if (PendingAuditEntries == null) { return; } _mediator.DispatchDataChangeEventsAsync(this).GetAwaiter().GetResult(); } public override async Task\u003cint\u003e SaveChangesAsync(bool acceptAllChangesOnSuccess, CancellationToken cancellationToken = default(CancellationToken)) { this.SetAuditInformation(_logger); PendingAuditEntries = _mediator != null ? this.TrackingChanges(_logger)?.ToList() : default; try { return await base.SaveChangesAsync(acceptAllChangesOnSuccess, cancellationToken); } finally { ProcessingChanges(); } } public override int SaveChanges(bool acceptAllChangesOnSuccess) { this.SetAuditInformation(_logger); PendingAuditEntries = _mediator != null ? this.TrackingChanges(_logger)?.ToList() : default; try { return base.SaveChanges(acceptAllChangesOnSuccess); } finally { ProcessingChanges(); } } }\rHandle DataEvent Implement your own handler by inheriting MediatR.INotificationHandler\u003cDataEvent\u003e, so you can store anything you need proactively. Use default audit service that we provided below. Default audit service In this part, we provide not only data audit service but access logging service.\nCore concept AuditContext The AuditContext contains information about user access log, data audit entries. It will be initialized while a request is starting, be fulfilled while the request pipeline is invoking, and be committed by the IAuditService when the request pipeline is finished.\nIAuditContextAccessor The accessor to access AuditContext in the scope.\nIAuditService The service that processes the audited information to store or send it to other systems.\nAuditMiddleware The middleware that inits the AuditContext at the start of the request. It also collects the important information about the request:\nUser, DateTime, Action RequestInfo: RequestId, Headers, Host, Method, Path, RemoteIpAddress ServerInfo: MachineName, OSVersion, SoftwareVersion, AppName ResponseInfo: StatusCode, Headers, ElapsedMilliseconds. The Data was intended to be filled by other middleware that you will implement yourself. The Message, Error may be set by this middleware if an exception was thrown while invoking the next steps of the pipeline and there is no other middleware filling it. Otherwise, it may be filled by a custom middleware like the Data. It must be placed after Authentication middleware to have User information.\nNOTE: It often increases by 30ms - 70ms in request response time because saves the audit information with the EF repository or gRPC (tested with SQL Server and PostgreSQL on Docker, it depends on whether there are any DataAudit entries or not, and database provider).\nThe figure below is the request processing flow with AuditMiddleware injected.\nAudit process Usage We currently provide two ways to use the audit services.\nEF repository Use the AuditMiddleware to collect audit information and directly persist into the EF repository.\n// Minimal application Program.cs using Juice.Audit.AspNetCore.Extensions; ... var builder = WebApplication.CreateBuilder(args); // configure Audit services with default usage builder.Services.ConfigureAuditDefault(builder.Configuration, options =\u003e { // configure database options //options.DatabaseProvider = \"PostgreSQL\"; }); // MediatR service is required for Audit services builder.Services.AddMediatR(typeof(Program)); ... var app = builder.Build(); ... // if specified, the authentication middleware must place before the AuditMiddleware to have User info. // app.UseAuthentication(); // use AuditMiddleware to handle audit for specified request app.UseAudit(\"yourAppName\", options =\u003e { options.Include(\"\", \"GET\"); options.Exclude(\"/Index\"); });\rgRPC repository Use the AuditMiddleware to collect audit information and remotely persist to the audit server by gRPC.\nIn this usage, we will use ConfigureAuditGrpcClient() instead of ConfigureAuditDefault() for the application.\n// Minimal application Program.cs using Juice.Audit.AspNetCore.Extensions; ... var builder = WebApplication.CreateBuilder(args); // configure Audit services to use gRPC client builder.Services.ConfigureAuditGrpcClient(options =\u003e { options.Address = new Uri(\"https://localhost:7285\"); // the audit server endpoint // configure grpc client factory options options.ChannelOptionsActions.Add(o =\u003e { o.HttpHandler = new SocketsHttpHandler { PooledConnectionIdleTimeout = Timeout.InfiniteTimeSpan, KeepAlivePingDelay = TimeSpan.FromSeconds(60), KeepAlivePingTimeout = TimeSpan.FromSeconds(30), EnableMultipleHttp2Connections = true }; }); }); // MediatR service is required for Audit services builder.Services.AddMediatR(typeof(Program)); ... var app = builder.Build(); ... // if specified, the authentication middleware must place before the AuditMiddleware to have User info. // app.UseAuthentication(); // use AuditMiddleware to handle audit for specified request app.UseAudit(\"yourAppName\", options =\u003e { options.Include(\"\", \"GET\"); options.Exclude(\"/Index\"); });\rWe also need an audit server to handle the audit messages.\n// Audit server Program.cs using Juice.Audit.AspNetCore.Extensions; ... var builder = WebApplication.CreateBuilder(args); // configure Audit services as a server builder.Services.ConfigureAuditGrpcHost(builder.Configuration, options =\u003e { options.DatabaseProvider = \"PostgreSQL\"; }); // MediatR and Grpc services is required for Audit services builder.Services.AddMediatR(typeof(Program)); builder.Services.AddGrpc(o =\u003e o.EnableDetailedErrors = true); ... var app = builder.Build(); ... // map gPRC endpoint to handle audit messages app.MapAuditGrpcServer();\rPlease follow this link to read about rRPC performance tips.\nConfiguration EF repositories You can configure DbOptions to specify database provider, schema… See DbOptions for more information.\nAudit filters You can configure AuditFilterOptions to specify the paths and methods you want to audit, as well as request/response headers to store in the access log.\nPath and method filtering to processing You can describe multiple paths, zero or more methods per path. The path and method are case insensitive You can define a rule with specified priority and then add it to Filters or load the rule from configuration You can use * to describe a single segment You can use # to describe zero or more segments Response status filtering You can describe multiple response status codes so that AuditMiddleware will process the request upon completion The status codes described will be associated with the filter path at the same time Request/response headers filtering to store You can use * to describe a single segment You can use # to describe zero or more segments Request headers will be stored by default: :authority:, accept-#, content-*, x-forwarded-#, referer, user-agent Response headers will be stored by default: content-* Some main methods of AuditFilterOptions that help us build the filter options:\nClear: clear all existing filter entries Include: append a filter entry to include path, methods… Exclude: append a filter entry to exclude path, methods… StoreEmptyRequestHeaders: clear all request header filters StoreRequestHeaders: add new request header filters StoreEmptyResponseHeaders: clear all response header filters StoreResponseHeaders: add new response header filters NOTE\nLeave blank (of Path, Methods, StatusCodes) will have the same meaning as any Rules added later by filter builder will have higher priority by default Rules added by configuration section will have the same priority level of 0 by default The code blocks below are two ways to configure the audit filter\n//Program.cs app.UseAudit(\"yourAppName\", options =\u003e { // describe the paths and methods to logging user acess and data audit options.Include(\"\", \"GET\"); // include any GET request options.Exclude(\"/Index\"); // exclude requests to /Index // include all POST, PUT request to the path that: // - starts with /kernel // - has one or more segment after // Ex: /kernel/foo, /kernel/foo/bar, /kernel/foo/bar/barbar ... options.Include(\"/kernel/*/#\", \"POST\", \"PUT\"); // OR binding from appsettings // builder.Configuration.Bind(\"Audit\", options); // Only store the request headers like: accept, accept-encoding, accept-language-x, // content-type, content-length... but not content, content-type-y options.StoreEmptyRequestHeaders() .StoreRequestHeaders(\"accept-#\", \"content-*\"); });\r//appsettings.json \"Audit:Filters\": [ // path filter antries { \"Methods\": [ \"POST\", \"PUT\", \"DELETE\" ], \"Priority\": -1 }, { \"IsExcluded\": true, \"Path\": \"/#/negotiate\" }, { \"IsExcluded\": true, \"Path\": \"/error/*\" }, { \"StatusCodes\": [400, 500] } ]\rThe model presents the filter entry here\nclass PathFilterEntry { public int Priority { get; set; } = 0; public bool IsExcluded { get; set; } = false; public string Path { get; set; } = string.Empty; public string[] Methods { get; set; } = Array.Empty\u003cstring\u003e(); public int[] StatusCodes { get; set; } = Array.Empty\u003cint\u003e(); }\rProgramming API Fulfill response information The Data, Msg, Err of ResponseInfo can only be assigned values once. In AuditMiddleware, we do not try to set Data but rather Msg and Err by handling the pipeline call exception. To set Msg, Err, Data in other middlewares or action filter, we can use IAuditContextAccessor service to access the AuditContext and then try to set the response information.\nauditContextAccessor.AuditContext?.UpdateResponseInfo(response =\u003e { response.TrySetMessage(\"An useful message\"); response.TrySetData(\"{\\\"foo\\\":\\\"bar\\\"}\"); });\rAdd more audit entries By default, we use DataEvenNotificationtHandler to handle DataEvent and add DataAudit entries, but you can add DataAudit entries manually by access the AuditContext.\nauditContextAccessor.AuditContext?.AddAuditEntries(entry1, entry2...);\rAdditional metadata If the current audit information is not enough, you can add more information to the Metadata by access the AuditContext.\nauditContextAccessor.AuditContext?.AccessRecord?.SetMetadata(key, value); // OR auditContextAccessor.AuditContext?.AccessRecord?.SetMetadataJson(jsonString);\rThe library can be accessed via Nuget:\nJuice.Audit Juice.Audit.Api.Contracts Juice.Audit.Api Juice.Audit.EF Juice.Audit.EF.SqlServer Juice.Audit.EF.PostgreSQL",
    "description": "Versions\rlatest\r7.0.2\rQuick access Data audit Configure entity model Implement an auditable DbContext Handle DataEvent Default audit service Core concept Usage Configuration Programming API Data audit We already have a data audit framework based on EF Core and fully implemented in the DbContextBase abstract class. It will send a DataEvent via MediatR’s notification, the object contains:",
    "tags": [],
    "title": "Audit services",
    "uri": "/other_services/audit/v7.0.2/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rCore features",
    "content": "Per-tenant configuration If you are trying to develop a multi-tenant application, you may need to access the tenant configuration. So we provide ITenantsConfiguration interface to access tenant configuration and a default JSON configuration source that will read configuration from {ConfigurationDirectory}/tenants/{TenantIdentifier}/{FileName}.\npublic interface ITenantsConfiguration : IConfiguration { }\rThe ITenantsConfiguration is inherited from IConfiguration. So after registering the service on application startup you can inject it and use like IConfiguration.\n... using Juice.Extensions.Configuration; ... // register service and configuration source to access // {WorkingDirectory}/tenants/{TenantIdentifier}/appsettings.Development.json services.AddTenantsConfiguration().AddTenantsJsonFile(\"appsettings.Development.json\");\rNOTE: It requires ITenant service\nYou can also implement ITenantsConfigurationSource interface to use a custom configuration source like DB, gRPC…\nThe library can be accessed via Nuget:\nJuice.Extensions.Configuration Scalared configuration We also provide IConfigurationSection extension methods to get scalared config so you can access a dictionary configuration.\n... using Juice.Extensions.Configuration; ... // appsettings.json // \"Options\": { // \"Dict\": { // \"A\": 2, // \"B\": false // } // } services.Configure\u003cScalaredOptions\u003e(options =\u003e { var config = configuration.GetSection(\"Options\").GetScalaredConfig\u003cScalaredOptions\u003e(); if (config != null) { options.Dict = config.Dict; } });\rThe library can be accessed via Nuget:\nJuice",
    "description": "Per-tenant configuration If you are trying to develop a multi-tenant application, you may need to access the tenant configuration. So we provide ITenantsConfiguration interface to access tenant configuration and a default JSON configuration source that will read configuration from {ConfigurationDirectory}/tenants/{TenantIdentifier}/{FileName}.\npublic interface ITenantsConfiguration : IConfiguration { }\rThe ITenantsConfiguration is inherited from IConfiguration. So after registering the service on application startup you can inject it and use like IConfiguration.",
    "tags": [],
    "title": "Configuration",
    "uri": "/core/configuration/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rCore features \u003e \rLogging",
    "content": "Versions\rlatest\r7.0.2\rThere are many great logging frameworks for .Net Core like Log4Net, SeriLog, NLog… However, if you wish to customize logging system for special purpose, then you can inherit the LoggerProvider abstract class:\npublic abstract class LoggerProvider : IDisposable, ILoggerProvider, ISupportExternalScope { ... public IExternalScopeProvider ScopeProvider { get; } /// \u003csummary\u003e /// Writes the specified log information to a log file. /// \u003c/summary\u003e public abstract void WriteLog\u003cTState\u003e(LogEntry\u003cTState\u003e entry, string formattedMessage); #region IDisposable Support /// \u003csummary\u003e /// Cleanup resources on disposing. /// \u003c/summary\u003e protected abstract void Cleanup(); ... #endregion }\rOnce you have an implementation, you can register it when you add logging:\nservices.AddLogging(builder =\u003e { builder.ClearProviders(); // optional builder.AddConfiguration(); // configure your options if needed // register service builder.Services.TryAddEnumerable( ServiceDescriptor.Singleton\u003cILoggerProvider, YourLoggerProvider\u003e()); });\rOr register to existing application logging builder:\nvar builder = WebApplication.CreateBuilder(args); // configure your options if needed // register service builder.Logging.Services.TryAddEnumerable( ServiceDescriptor.Singleton\u003cILoggerProvider, YourLoggerProvider\u003e());\rSee Background service logging and XUnit output logging for example.\nThe library can be accessed via Nuget:\nJuice.Extensions.Logging",
    "description": "Versions\rlatest\r7.0.2\rThere are many great logging frameworks for .Net Core like Log4Net, SeriLog, NLog… However, if you wish to customize logging system for special purpose, then you can inherit the LoggerProvider abstract class:",
    "tags": [],
    "title": "Logging",
    "uri": "/core/logging/v7.0.2/index.html"
  },
  {
    "breadcrumb": "Juice's documentation",
    "content": "Logging\nConfiguration\nOptions\nSwagger\nMediator\nEvent bus\nEntity framework\nIntegration services\nxUnit\nMulti-tenant\nModular",
    "description": "Logging\nConfiguration\nOptions\nSwagger\nMediator\nEvent bus\nEntity framework\nIntegration services\nxUnit\nMulti-tenant\nModular",
    "tags": [],
    "title": "Core features",
    "uri": "/core/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rQuickstarts",
    "content": "The main purpose of this layer is to implement repository interfaces which were defined in Domain layer. If you need to customize the entity classes to fit the infrastructure (like EF) or optimize the DB, you can do it here.\nIt’s named {namespace}.{feature}.{infrastructure}. Eg: Juice.Abc.EF\nBasically, we will create a DbContext that inherits DbContextBase to work with the database. Then use the created DbContext to implement repositories.\nThe project tree will look like this:\n|-- Dtos // optional |-- Migrations // only if you have selected a DB backend for your application |-- Repositories | |-- AbcRepository.cs |-- DependencyInjection // optional | |-- YourServiceCollectionExtensions.cs // to register your infrastructure services |-- YourDbContext.cs\rSeparate migrations If you want to support multiple DB backends like SqlServer, PostgreSQL… then you need to separate migrations into other projects. Eg: Juice.Abc.EF.SqlServer and Juice.Abc.EF.PostgreSQL.\nThese are steps to separete migrations:\nFirstly, you must implement an IDesignTimeDbContextFactory for your DBContext ... using Juice.Extensions.DependencyInjection; ... public class AbcDbContextFactory : IDesignTimeDbContextFactory\u003cAbcDbContext\u003e { public WorkflowDbContext CreateDbContext(string[] args) { Environment.SetEnvironmentVariable(\"ASPNETCORE_ENVIRONMENT\", \"Development\"); var resolver = new DependencyResolver { CurrentDirectory = AppContext.BaseDirectory }; resolver.ConfigureServices(services =\u003e { // Register DbContext class var configService = services.BuildServiceProvider().GetRequiredService\u003cIConfigurationService\u003e(); var configuration = configService.GetConfiguration(args); var provider = configuration.GetSection(\"Provider\").Get\u003cstring\u003e() ?? \"SqlServer\"; var connectionName = provider switch { \"PostgreSQL\" =\u003e \"PostgreConnection\", \"SqlServer\" =\u003e \"SqlServerConnection\", _ =\u003e throw new NotSupportedException($\"Unsupported provider: {provider}\") } ; var connectionString = configuration.GetConnectionString(connectionName); services.AddDbContext\u003cAbcDbContext\u003e(options =\u003e { switch (provider) { case \"PostgreSQL\": AppContext.SetSwitch(\"Npgsql.EnableLegacyTimestampBehavior\", true); options.UseNpgsql( connectionString, x =\u003e { x.MigrationsAssembly(\"Juice.Abc.EF.PostgreSQL\"); }); break; case \"SqlServer\": options.UseSqlServer( connectionString, x =\u003e { x.MigrationsAssembly(\"Juice.Abc.EF.SqlServer\"); }); break; default: throw new NotSupportedException($\"Unsupported provider: {provider}\"); } }); }); return resolver.ServiceProvider.GetRequiredService\u003cAbcDbContext\u003e(); } }\rCreate a web application then add references to all infrastructure projects. Eg: Juice.Abc.Host Register your DbContext into IServiceCollection Set it as a startup project In the Package Manager Console Select the Default project to your backend project as same as the provider that you want to generate the migration. Eg: Juice.Abc.EF.PostgreSQL Exec command: Add-Migration InitDb -Context AbcDbContext -OutputDir Migrations -Args \"--provider PostgreSQL\"\rCQRS The typical CQRS implementation will segregate the Read/Write model and also segregate the Read/Write DB. So it can be used together with complex pattern Event Sourcing or is it simply complicated to implement for newbies.\nHowever, a simpler approach is to use ReadOnly DB to query or read models. It’s supported by several types of databases. So you can create a DBContext intended to be read-only and use it with a read-only connection string.",
    "description": "The main purpose of this layer is to implement repository interfaces which were defined in Domain layer. If you need to customize the entity classes to fit the infrastructure (like EF) or optimize the DB, you can do it here.\nIt’s named {namespace}.{feature}.{infrastructure}. Eg: Juice.Abc.EF\nBasically, we will create a DbContext that inherits DbContextBase to work with the database. Then use the created DbContext to implement repositories.\nThe project tree will look like this:",
    "tags": [],
    "title": "Infrastructure",
    "uri": "/quickstart/infrastructure/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rCore features \u003e \rxUnit",
    "content": "Some special tests require special conditions so we have to ignore them in the CI test. So we can add [IgnoreOnCIFact] or [IgnoreOnCITheory] attribute to specified tests to bypass.\nusing Juice.XUnit; public class EFTest { [IgnoreOnCIFact(TestPriority(99)] public async Task Shoud_run_first() { } [IgnoreOnCITheory(TestPriority(98)] [InlineData(\"SqlServer\")] [InlineData(\"PostgreSQL\")] public async Task Shoud_run_second(string provider) { } }\rThe library can be accessed via Nuget:\nJuice.XUnit",
    "description": "Some special tests require special conditions so we have to ignore them in the CI test. So we can add [IgnoreOnCIFact] or [IgnoreOnCITheory] attribute to specified tests to bypass.\nusing Juice.XUnit; public class EFTest { [IgnoreOnCIFact(TestPriority(99)] public async Task Shoud_run_first() { } [IgnoreOnCITheory(TestPriority(98)] [InlineData(\"SqlServer\")] [InlineData(\"PostgreSQL\")] public async Task Shoud_run_second(string provider) { } }\rThe library can be accessed via Nuget:",
    "tags": [],
    "title": "CI-Ignore",
    "uri": "/core/xunit/ci_ignore/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rCore features",
    "content": "Mutable Options To change options in the application, we can use IOptionsMutable\u003cT\u003e interface:\npublic interface IOptionsMutable\u003cout T\u003e : IOptionsSnapshot\u003cT\u003e where T : class, new() { // Update T field by field Task\u003cbool\u003e UpdateAsync(Action\u003cT\u003e applyChanges); }\rTo use IOptionsMutable\u003cT\u003e we must also register some required services.\n... using Juice.Extensions.Options.DependencyInjection; ... // your changed options will be write to {WorkingDirectory}/appsettings.Development.json services.UseOptionsMutableFileStore(\"appsettings.Development.json\"); // OR separated appsettings file for strongly typed // services.UseOptionsMutableFileStore\u003cOptions\u003e($\"appsettings.Separated.Development.json\"); // configure your Options class before use services.ConfigureMutable\u003cOptions\u003e(configuration.GetSection(\"Options\"));\rAfter that, we can inject IOptionsMutable\u003cOptions\u003e and use it like IOptionsSnapshot\u003cOptions\u003e. We can also call UpdateAsync method to update options.\nvar options = serviceProvider.GetRequiredService\u003cIOptionsMutable\u003cOptions\u003e\u003e(); await options.UpdateAsync(o =\u003e { //o.Something = \"something else\"; });\rPer-tenant Options Use ITenantsOptions\u003cT\u003e to access per-tenant configured options.\n// Per-tenant options snapshot public interface ITenantsOptions\u003cT\u003e : IOptionsSnapshot\u003cT\u003e where T : class, new() { }\rWe will register tenant configuration services to use per-tenant options accessor.\n... using Juice.Extensions.Options.DependencyInjection; ... // register tenant configuration services services.AddTenantsConfiguration().AddTenantsJsonFile(\"appsettings.Development.json\"); // configure typed options services.ConfigureTenantsOptions\u003cOptions\u003e(\"Options\"); ... // use ITenantsOptions like IOptionsSnapshot var options = serviceProvider.GetRequiredService\u003cITenantsOptions\u003cOptions\u003e\u003e();\rNOTE: It requires ITenant service\nPer-tenant Mutable Options This is combined of per-tenant options and mutable options.\npublic interface ITenantsOptionsMutable\u003cT\u003e : ITenantsOptions\u003cT\u003e, IOptionsMutable\u003cT\u003e where T : class, new() { }\r... using Juice.Extensions.Options.DependencyInjection; ... // register tenant configuration services services.AddTenantsConfiguration().AddTenantsJsonFile(\"appsettings.Development.json\"); // register multi-tenant mutable configuration source services.UseTenantsOptionsMutableFileStore(\"appsettings.Development.json\"); // configure multi-tenant mutable options services.ConfigureTenantsOptionsMutable\u003cOptions\u003e(\"Options\"); ... // use ITenantsOptionsMutable like IOptionsSnapshot var options = serviceProvider.GetRequiredService\u003cITenantsOptionsMutable\u003cOptions\u003e\u003e(); // now we can update Options await options.UpdateAsync(o =\u003e { //o.Something = \"something else\"; });\rNOTE: It requires ITenant service\nThe library can be accessed via Nuget:\nJuice.Extensions.Options",
    "description": "Mutable Options To change options in the application, we can use IOptionsMutable\u003cT\u003e interface:\npublic interface IOptionsMutable\u003cout T\u003e : IOptionsSnapshot\u003cT\u003e where T : class, new() { // Update T field by field Task\u003cbool\u003e UpdateAsync(Action\u003cT\u003e applyChanges); }\rTo use IOptionsMutable\u003cT\u003e we must also register some required services.\n... using Juice.Extensions.Options.DependencyInjection; ... // your changed options will be write to {WorkingDirectory}/appsettings.Development.json services.UseOptionsMutableFileStore(\"appsettings.Development.json\"); // OR separated appsettings file for strongly typed // services.UseOptionsMutableFileStore\u003cOptions\u003e($\"appsettings.Separated.Development.json\"); // configure your Options class before use services.ConfigureMutable\u003cOptions\u003e(configuration.GetSection(\"Options\"));\rAfter that, we can inject IOptionsMutable\u003cOptions\u003e and use it like IOptionsSnapshot\u003cOptions\u003e. We can also call UpdateAsync method to update options.",
    "tags": [],
    "title": "Options",
    "uri": "/core/options/index.html"
  },
  {
    "breadcrumb": "Juice's documentation",
    "content": "Background service Logging\nManaged service",
    "description": "Background service Logging\nManaged service",
    "tags": [],
    "title": "Background service",
    "uri": "/bg_service/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rQuickstarts",
    "content": "This project will be named {namespace}.{feature}.Api.Contracts.\nIn this project, we will define the document that describes how the API works. Its components depend on what you choose to implement your API.\nDtos for REST Protos for gRPC IntegrationEvents for event bus Anything else that you have to share beetwen services",
    "description": "This project will be named {namespace}.{feature}.Api.Contracts.\nIn this project, we will define the document that describes how the API works. Its components depend on what you choose to implement your API.\nDtos for REST Protos for gRPC IntegrationEvents for event bus Anything else that you have to share beetwen services",
    "tags": [],
    "title": "API Contracts",
    "uri": "/quickstart/contracts/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rOther services",
    "content": "In this section, we introduce File storage to build a file management system.\nPurposes Provides a web API for large file uploads and a javascript library to working on web client Resumeable upload process Easily integrated with MAM system Multiple file transfer protocols on the backend Multiple storages on the same backend Concept File storage sequence diagram IStorageResolver This service will resolves Storage according to its identity (it is storage’s web endpoint by default).\nIStorage It is a proxy that contains backend storage endpoints so we can access storage using multiple endpoints and protocols.\nIStorageProvider It provides methods to access the endpoint depending on its protocol. By default, we have implemented FTP, Samba and LocalDisk access providers.\nIUploadManager It manages the upload process by storing the upload process to IUploadRepo to continue it and can load-balance between servers.\nAfter a successful upload, it will try to add the uploaded file to IFileRepo for storage.\nStorageMiddleware This middleware handles requests, attemps to resolve Storage by requesting enpoint and operates it.\nUsage To use storage services, please call the AddStorage() on IServiceCollection instance. By default, we have implemented in-memory repositories to store upload processes.\n// Program.cs using Juice.Storage.Extensions; using Juice.Storage.Local; ... var builder = WebApplication.CreateBuilder(args); // add storage services builder.Services.AddStorage(); // use in-memory repos builder.Services.AddInMemoryUploadManager(builder.Configuration.GetSection(\"Juice:Storage\")); // maintain timed-out uploads builder.Services.AddInMemoryStorageMaintainServices(builder.Configuration.GetSection(\"Juice:Storage\"), new string[] { \"/storage\", \"/storage1\" }, options =\u003e { options.CleanupAfter = TimeSpan.FromMinutes(5); options.Interval = TimeSpan.FromMinutes(1); }); // access FTP, Samba, LocalDisk enpoints builder.Services.AddLocalStorageProviders(); ... var app = builder.Build(); ... app.UseStorage(options =\u003e { options.Endpoints = new string[] { \"/storage\", \"/storage1\" }; options.SupportDownloadByPath = true; }); app.Run();\rConfiguration In-memory storage options { \"Juice:Storage\": { \"Storages\": [ { \"WebBasePath\": \"/storage\", \"Endpoints\": [ { \"Protocol\": \"LocalDisk\", \"Uri\": \"C:\\\\Workspace\\\\Storage\" } ] }, { \"WebBasePath\": \"/storage1\", \"Endpoints\": [ { \"Protocol\": \"Smb\", \"BasePath\": \"\\\\\\\\ip-or-name\", \"Uri\": \"\\\\\\\\ip-or-name\\\\path\\\\to\\\\storage\", //\"Identity\": \"demo\", //\"Password\": \"demo\" } ] } ] } }\rIn these options:\nWebBasePath: used to resolve storage if the client requests this path Endpoints: list of endpoints that will be used for the server to access the file storage (we currently support FTP, Smb, LocalDisk protocols) Storage maintain options We can configure StorageMaintainOptions using configuration section or configure action (see the code block above).\nCleanupAfter: the waiting period before the upload times out Interval: the waiting time between checks Storage middleware options We can configure StorageMiddlewareOptions directly using configure action.\nEndpoints: web path matches the storage identity SupportDownloadByPath: if enabled, clients can download the file if the correct file path is provided Upload Options We can configure UploadOptions using configuration section or configure action.\nSectionSize: specify max size for each upload sections DeleteOnAbort: behavior when a client’s’ upload request is aborted NOTE\nYou should configure your web server’s security policies to match SectionSize Authorization policies If you have added app.UseAuthorization() then the storage authorization policies need to be configured.\n// Program.cs using Juice.Storage.Authorization; ... builder.Services.AddAuthorization(options =\u003e { options.AddPolicy(StoragePolicies.CreateFile, policy =\u003e { // policy requirements }); options.AddPolicy(StoragePolicies.DownloadFile, policy =\u003e { // policy requirements }); });\rThe sample source code is available on github.\nThe library can be accessed via Nuget and npmjs:\nJuice.Storage Juice.Storage.Local @juice-js/upload",
    "description": "In this section, we introduce File storage to build a file management system.\nPurposes Provides a web API for large file uploads and a javascript library to working on web client Resumeable upload process Easily integrated with MAM system Multiple file transfer protocols on the backend Multiple storages on the same backend Concept File storage sequence diagram IStorageResolver This service will resolves Storage according to its identity (it is storage’s web endpoint by default).",
    "tags": [],
    "title": "File storage",
    "uri": "/other_services/file_storage/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rOther services",
    "content": "We have implemented a plugin management service that supports application load and execute service from plugin by load its assembly dynamically.\nPlugin sequence diagram To implement plugin pattern, you first understanding the AssemblyLoadContext.\nCore concept Application The application will host all services including the IPluginServiceProvider and IPluginsManager services. Application accesses Plugin services through IPluginServiceProvider, and manages plugins (Load/Unload) via IPluginsManager.\nPluginsManager This service manages all plugins by Load/Unload them. Some Shared Services can be shared between Application and Plugins when we load them.\nNOTE\nAny service tha can be called from Application or passed from Application is a shared service Any services shared with plugin must be excluded from the plugin directory We can share the service instead of its implementation classes, so we can use different implementations between Application and Plugins These services will be shared with plugin by default:\nIServiceCollection IConfiguration Plugin The plugin will implement our shared services. To avoid libraries version conflicts and easy of implementation, it should have a reference to the Microsoft.AspNetCore.App so Application and Plugin will share this framework.\nOn load, all Startup classes will be discovered and their ConfigureServices() method called with IServiceCollection and IConfiguration argurments. So the plugin can have an owned appsettings file.\nAfter loaded, plugin will have its own ServiceProvider, which is useful when resolving services from the plugin.\nUsage To use plugin services, please call the AddPlugins() on IServiceCollection instance.\nusing Microsoft.Extensions.DependencyInjection; ... var builder = WebApplication.CreateBuilder(args); builder.Services.AddPlugins(options =\u003e { options.AbsolutePaths = pluginPaths; options.ConfigureSharedServices = (services, sp) =\u003e { // SharedService will be shared to plugins services.AddScoped(sp1 =\u003e { var s = sp.GetRequiredService\u003cSharedService\u003e(); var l = sp.GetRequiredService\u003cILoggerFactory\u003e().CreateLogger(\"shared\"); l.LogInformation(\"Shared service created {0}\", s.Id); return s; }); }; });\rPlugin implementation The quote below is a simple project file of a plugin. Please refer to Dotnet tutorials for details.\n// Plugin.csprj \u003cProject Sdk=\"Microsoft.NET.Sdk\"\u003e \u003cPropertyGroup\u003e \u003cTargetFrameworks\u003enet6.0,net7.0\u003c/TargetFrameworks\u003e \u003cImplicitUsings\u003eenable\u003c/ImplicitUsings\u003e \u003cNullable\u003eenable\u003c/Nullable\u003e \u003cEnableDynamicLoading\u003etrue\u003c/EnableDynamicLoading\u003e \u003c!-- This element is important --\u003e \u003c/PropertyGroup\u003e \u003cItemGroup Label=\"AspNetCore\"\u003e \u003cFrameworkReference Include=\"Microsoft.AspNetCore.App\" /\u003e \u003c/ItemGroup\u003e \u003cItemGroup\u003e \u003cProjectReference Include=\"..\\Juice.Plugins.Tests.Common\\Juice.Plugins.Tests.Common.csproj\" /\u003e \u003cProjectReference Include=\"..\\Juice.Plugins.Tests.PluginBase\\Juice.Plugins.Tests.PluginBase.csproj\"\u003e \u003cPrivate\u003efalse\u003c/Private\u003e \u003c!-- This element is important --\u003e \u003cExcludeAssets\u003eruntime\u003c/ExcludeAssets\u003e \u003c!-- This element is important --\u003e \u003c/ProjectReference\u003e \u003c/ItemGroup\u003e \u003c/Project\u003e\r// Plugin Startup.cs public class Startup { public void ConfigureServices(IServiceCollection services, IConfiguration configuration) { services.AddLogging(builder =\u003e { builder.AddConsole(); builder.AddConfiguration(configuration.GetSection(\"Logging\")); }); services.AddScoped\u003cMessageService\u003e(); services.AddScoped\u003cICommand, HelloCommand\u003e(); } }\rThe full source code for this sample is available on github.\nThe library can be accessed via Nuget:\nJuice.Plugins",
    "description": "We have implemented a plugin management service that supports application load and execute service from plugin by load its assembly dynamically.\nPlugin sequence diagram To implement plugin pattern, you first understanding the AssemblyLoadContext.\nCore concept Application The application will host all services including the IPluginServiceProvider and IPluginsManager services. Application accesses Plugin services through IPluginServiceProvider, and manages plugins (Load/Unload) via IPluginsManager.\nPluginsManager This service manages all plugins by Load/Unload them. Some Shared Services can be shared between Application and Plugins when we load them.",
    "tags": [],
    "title": "Plugins",
    "uri": "/other_services/plugins/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rQuickstarts",
    "content": "This project will be named {namespace}.{feature}.Api.\nIn this project, we will implement API that is defined in contracts and other integration services.\nSwagger SignalR gRPC implementation Integration event subscribing and handling Handle domain events to publish integration events If you are building a monolithic application, then you can use the internal event bus instead of external. You can also handle domain events from other domains directly instead of implementing integration events.",
    "description": "This project will be named {namespace}.{feature}.Api.\nIn this project, we will implement API that is defined in contracts and other integration services.\nSwagger SignalR gRPC implementation Integration event subscribing and handling Handle domain events to publish integration events If you are building a monolithic application, then you can use the internal event bus instead of external. You can also handle domain events from other domains directly instead of implementing integration events.",
    "tags": [],
    "title": "API",
    "uri": "/quickstart/api/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rCore features",
    "content": "Include XML comments This is a SwaggerGenOptions’ extension to include xml comments from referenced assemblies.\n... using Juice.Extensions.Swagger; ... services.ConfigureSwaggerGen(c =\u003e { ... c.IncludeReferencedXmlComments(); });\rThe library can be accessed via Nuget:\nJuice.AspNetCore SwaggerIgnoreFilter To ignore model properties from Swagger document generator but keep it in serialized JSON, we implement ApiIgnoreAttribute and ISchemaFilter interface to remove properties those have ApiIgnoreAttribute from OpenApiSchema\npublic class SwaggerIgnoreFilter : ISchemaFilter { public void Apply(OpenApiSchema schema, SchemaFilterContext context) { ... } }\rRegister filter into DI\n... using Juice.Extensions.Swagger; ... // use default config services.AddSwaggerWithDefaultConfigs(); // OR configure swagger yourself // services.AddSwaggerGen(c =\u003e // { // ... // c.SchemaFilter\u003cSwaggerIgnoreFilter\u003e(); // });\rThe library can be accessed via Nuget:\nJuice.AspNetCore ApiIgnore attribute This attribute is useful to Swagger skip generate API for specified properties when combined with the above SwaggerIgnoreFilter.\nusing Juice.CompnentModel; public class ViewMode{ [ApiIgnore] public int OnlyAppearInJSON { get; set; } }\rThe library can be accessed via Nuget:\nJuice",
    "description": "Include XML comments This is a SwaggerGenOptions’ extension to include xml comments from referenced assemblies.\n... using Juice.Extensions.Swagger; ... services.ConfigureSwaggerGen(c =\u003e { ... c.IncludeReferencedXmlComments(); });\rThe library can be accessed via Nuget:\nJuice.AspNetCore SwaggerIgnoreFilter To ignore model properties from Swagger document generator but keep it in serialized JSON, we implement ApiIgnoreAttribute and ISchemaFilter interface to remove properties those have ApiIgnoreAttribute from OpenApiSchema",
    "tags": [],
    "title": "Swagger",
    "uri": "/core/swagger/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rOther services",
    "content": "This service is useful for measure the execution time of a method by create the execution scopes and checkpoints in your code, and then print the details of execution time step by step to determine where is the slowly code. You can use it with new transient instance to meansure inside a class, method, or use dependency injection pattern to meansure cross services.\nITimeTracker timeTracker = new TimeTracker(); using (timeTracker.BeginScope(\"Test\")) { // Do something await Task.Delay(12); timeTracker.Checkpoint(\"Checkpoint 0\"); using (timeTracker.BeginScope(\"Inner Test\")) { // Do something await Task.Delay(15); using (timeTracker.BeginScope(\"Inner Inner Test\")) { // Do something timeTracker.Checkpoint(\"Checkpoint 1.1\"); await Task.Delay(20); timeTracker.Checkpoint(\"Checkpoint 1.2\"); } } timeTracker.Checkpoint(\"Checkpoint 1\"); using (timeTracker.BeginScope(\"Inner Test 2\")) { // Do something await Task.Delay(10); timeTracker.Checkpoint(\"Checkpoint 1.3\"); timeTracker.Checkpoint(\"Checkpoint 1.4\"); } } Console.WriteLine(timeTracker.ToString()); // Output: _______________________________________________________ | Scope | Depth | Elapsed Time | |-------------------------------------------------------| | « Test | 1 | › 429.7 µs | | › Checkpoint 0 | 1 | + 16.21 ms | | « Inner Test | 2 | › 16.67 ms | | « Inner Inner Test | 3 | › 31.08 ms | | › Checkpoint 1.1 | 3 | + 4.2 µs | | › Checkpoint 1.2 | 3 | + 31.89 ms | | » Inner Inner Test | 3 | 32.10 ms | | » Inner Test | 2 | 46.77 ms | | › Checkpoint 1 | 1 | + 46.83 ms | | « Inner Test 2 | 2 | › 63.46 ms | | › Checkpoint 1.3 | 2 | + 15.07 ms | | › Checkpoint 1.4 | 2 | + 2.1 µs | | » Inner Test 2 | 2 | 15.07 ms | | » Test | 1 | 78.13 ms | |-------------------------------------------------------| | Total | | 79.36 ms | '-------------------------------------------------------'\rInside the Elapsed Time column:\n‘›’ symbol means the time elapsed from begin of the measurement ‘+’ symbol means the time elapsed from begin of the scope or the last checkpoint",
    "description": "This service is useful for measure the execution time of a method by create the execution scopes and checkpoints in your code, and then print the details of execution time step by step to determine where is the slowly code. You can use it with new transient instance to meansure inside a class, method, or use dependency injection pattern to meansure cross services.\nITimeTracker timeTracker = new TimeTracker(); using (timeTracker.BeginScope(\"Test\")) { // Do something await Task.Delay(12); timeTracker.Checkpoint(\"Checkpoint 0\"); using (timeTracker.BeginScope(\"Inner Test\")) { // Do something await Task.Delay(15); using (timeTracker.BeginScope(\"Inner Inner Test\")) { // Do something timeTracker.Checkpoint(\"Checkpoint 1.1\"); await Task.Delay(20); timeTracker.Checkpoint(\"Checkpoint 1.2\"); } } timeTracker.Checkpoint(\"Checkpoint 1\"); using (timeTracker.BeginScope(\"Inner Test 2\")) { // Do something await Task.Delay(10); timeTracker.Checkpoint(\"Checkpoint 1.3\"); timeTracker.Checkpoint(\"Checkpoint 1.4\"); } } Console.WriteLine(timeTracker.ToString()); // Output: _______________________________________________________ | Scope | Depth | Elapsed Time | |-------------------------------------------------------| | « Test | 1 | › 429.7 µs | | › Checkpoint 0 | 1 | + 16.21 ms | | « Inner Test | 2 | › 16.67 ms | | « Inner Inner Test | 3 | › 31.08 ms | | › Checkpoint 1.1 | 3 | + 4.2 µs | | › Checkpoint 1.2 | 3 | + 31.89 ms | | » Inner Inner Test | 3 | 32.10 ms | | » Inner Test | 2 | 46.77 ms | | › Checkpoint 1 | 1 | + 46.83 ms | | « Inner Test 2 | 2 | › 63.46 ms | | › Checkpoint 1.3 | 2 | + 15.07 ms | | › Checkpoint 1.4 | 2 | + 2.1 µs | | » Inner Test 2 | 2 | 15.07 ms | | » Test | 1 | 78.13 ms | |-------------------------------------------------------| | Total | | 79.36 ms | '-------------------------------------------------------'\rInside the Elapsed Time column:",
    "tags": [],
    "title": "Measurement",
    "uri": "/other_services/measurement/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rCore features",
    "content": "We provide IdentifiedCommand pattern to deduplicate incoming events with built-in EF backend (SqlServer/PostgreSQL) or Redis backend. Please follow the link Implement idempotent Commands for more information.\nawait mediator.Send(new IdentifiedCommand\u003cOriginCommand\u003e(originCommand, originCommandId));\rThe request manager will verify originCommandId does not exist before sending originCommand to your OriginCommandHandler.\nEF backend Please register request management services with your application schema before use.\n... using Juice.MediatR.RequestManager.EF.DependencyInjection; ... services.AddRequestManager(configuration, options =\u003e { options.DatabaseProvider = \"SqlServer\"; // PostgreSQL options.Schema = your-app-schema; options.ConnectionName = \"SqlServerConnection\"; }); // migrate DB if needed var context = resolver.ServiceProvider.GetRequiredService\u003cClientRequestContext\u003e(); var pendingMigrations = await context.Database.GetPendingMigrationsAsync(); if (pendingMigrations.Any()) { Console.WriteLine($\"[{schema}][ClientRequestContext] You have {pendingMigrations.Count()} pending migrations to apply.\"); Console.WriteLine(\"[ClientRequestContext] Applying pending migrations now\"); await context.Database.MigrateAsync(); }\rThe library can be accessed via Nuget:\nJuice.MediatR.RequestManager.EF Juice.MediatR.RequestManager.EF.SqlServer Juice.MediatR.RequestManager.EF.PostgreSQL Redis backend If you already have Redis so you can use it as a backend.\n... using Juice.MediatR.Redis.DependencyInjection; ... services.AddRedisRequestManager(options =\u003e { options.ConnectionString = configuration.GetConnectionString(\"Redis\"); });\rThe library can be accessed via Nuget:\nJuice.MediatR.Redis",
    "description": "We provide IdentifiedCommand pattern to deduplicate incoming events with built-in EF backend (SqlServer/PostgreSQL) or Redis backend. Please follow the link Implement idempotent Commands for more information.\nawait mediator.Send(new IdentifiedCommand\u003cOriginCommand\u003e(originCommand, originCommandId));\rThe request manager will verify originCommandId does not exist before sending originCommand to your OriginCommandHandler.\nEF backend Please register request management services with your application schema before use.\n... using Juice.MediatR.RequestManager.EF.DependencyInjection; ... services.AddRequestManager(configuration, options =\u003e { options.DatabaseProvider = \"SqlServer\"; // PostgreSQL options.Schema = your-app-schema; options.ConnectionName = \"SqlServerConnection\"; }); // migrate DB if needed var context = resolver.ServiceProvider.GetRequiredService\u003cClientRequestContext\u003e(); var pendingMigrations = await context.Database.GetPendingMigrationsAsync(); if (pendingMigrations.Any()) { Console.WriteLine($\"[{schema}][ClientRequestContext] You have {pendingMigrations.Count()} pending migrations to apply.\"); Console.WriteLine(\"[ClientRequestContext] Applying pending migrations now\"); await context.Database.MigrateAsync(); }\rThe library can be accessed via Nuget:",
    "tags": [],
    "title": "Mediator",
    "uri": "/core/mediator/index.html"
  },
  {
    "breadcrumb": "Juice's documentation",
    "content": "Other services Logging service\nAudit service\nFile storage\nPlugins",
    "description": "Other services Logging service\nAudit service\nFile storage\nPlugins",
    "tags": [],
    "title": "Other services",
    "uri": "/other_services/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rCore features",
    "content": "Versions\rlatest\r7.x\rTo communicate between services we defined an IEventBus interface with a built-in RabbitMQ broker. Please follow up Implementing event-based communication between microservices for details.\nnamespace Juice.EventBus { /// \u003csummary\u003e /// Event bus /// \u003c/summary\u003e public interface IEventBus { /// \u003csummary\u003e /// Publish \u003csee cref=\"IntegrationEvent\"/\u003e to implemented broker like RabbitMQ, ServiceBus... /// \u003c/summary\u003e /// \u003cparam name=\"event\"\u003e\u003c/param\u003e /// \u003cparam name=\"tenantId\"\u003e\u003c/param\u003e Task PublishAsync(IntegrationEvent @event, string? tenantId = default); /// \u003csummary\u003e /// Subscribe an \u003csee cref=\"IntegrationEvent\"/\u003e with specified \u003csee cref=\"IIntegrationEventHandler{T}\"/\u003e /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e /// \u003ctypeparam name=\"TH\"\u003e\u003c/typeparam\u003e void Subscribe\u003cT, TH\u003e(string? key = default) where T : IntegrationEvent where TH : IIntegrationEventHandler\u003cT\u003e; /// \u003csummary\u003e /// Subscribe an \u003csee cref=\"IntegrationEvent\"/\u003e with specified \u003csee cref=\"IIntegrationEventHandler{T}\"/\u003e /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e /// \u003ctypeparam name=\"TH\"\u003e\u003c/typeparam\u003e void Unsubscribe\u003cT, TH\u003e(string? key = default) where TH : IIntegrationEventHandler\u003cT\u003e where T : IntegrationEvent; } }\rRabbitMQ broker To use RabbitMQ broker as an event bus backend, we register RabbitMQEventBus services via IServiceCollection extension\n... using Juice.EventBus.RabbitMQ.DependencyInjection ... // Register IEventBus service services.RegisterRabbitMQEventBus(configuration.GetSection(\"RabbitMQ\")); // OR // Register strongly typed service // services.RegisterRabbitMQEventBus\u003cTyped\u003e(configuration.GetSection(\"RabbitMQ\")); // OR // services.RegisterRabbitMQEventBus(configuration.GetSection(\"RabbitMQ\"), options=\u003e { // configure options here // }); // RabbitMQ options // \"RabbitMQ\": { // \"RabbitMQEnabled\": false, // \"SubscriptionClientName\": \"xunit_test\", // client name must unique for a service (not service instance) // \"RetryCount\": 5, // \"Connection\": \"your_rabbitmq_host\", // \"Port\": 5672, // \"VirtualHost\": null, // \"UserName\": null, // \"Password\": null, // \"ExchangeType: null, // \"QueueType\": null, // \"AckOnProcessed\": null // }\rThe library can be accessed via Nuget:\nJuice.EventBus.RabbitMQ Implementation IntegrationEvent You can define your integration event that inherit IntegrationEvent record then publish throw IEventBus\nusing Juice.EventBus; public record ContentPublishedIntegrationEvent : IntegrationEvent { public ContentPublishedIntegrationEvent(string message) { Message = message; } public string Message { get; set; } }\rusing Juice.EventBus; ... await eventBus.PublishAsync(new ContentPublishedIntegrationEvent($\"Hello\"));\rThe library can be accessed via Nuget:\nJuice.EventBus IntegrationEventHandler Someone will implement an integration handler from IIntegrationEventHandler interface in other app to handle your integration event for their purposes.\nFor example: a handler that print received message and event time.\n... using Juice.EventBus; ... public class ContentPublishedIntegrationEventHandler : IIntegrationEventHandler\u003cContentPublishedIntegrationEvent\u003e { private ILogger _logger; public ContentPublishedIntegrationEventHandler(ILogger\u003cContentPublishedIntegrationEventHandler\u003e logger) { _logger = logger; } public async Task HandleAsync(ContentPublishedIntegrationEvent @event) { await Task.Yield(); _logger.LogInformation(\"[X] Received {0} at {1}\", @event.Message, @event.CreationDate); } }\rThen register into DI and subscribe event\n// configure services services.AddTransient\u003cContentPublishedIntegrationEventHandler\u003e(); ... // configure WebApplication var eventBus = app.Services.GetRequiredService\u003cIEventBus\u003e(); eventBus.Subscribe\u003cContentPublishedIntegrationEvent, ContentPublishedIntegrationEventHandler\u003e();\rThe library can be accessed via Nuget:\nJuice.EventBus IntegrationEventLog It is a part of balanced approach for atomicity and resiliency when publishing to the event bus. You can follow Designing atomicity and resiliency when publishing to the event bus topic for more information. We provide IIntegrationEventLogService interface with an implementation for EF backend use SQLServer or PostgreSQL.\npublic interface IIntegrationEventLogService : IDisposable { IntegrationEventLogContext LogContext { get; } // Use to process pending events Task\u003cIEnumerable\u003cIntegrationEventLogEntry\u003e\u003e RetrieveEventLogsPendingToPublishAsync(Guid transactionId); // Save an integration event within a same transaction with domain DBContext Task SaveEventAsync(IntegrationEvent @event, IDbContextTransaction transaction); // Change event state after publish it to the service bus Task MarkEventAsPublishedAsync(Guid eventId); // Change event state before publish it to the service bus Task MarkEventAsInProgressAsync(Guid eventId); // Change event state on failure publising Task MarkEventAsFailedAsync(Guid eventId); } public interface IIntegrationEventLogService\u003cout TContext\u003e : IIntegrationEventLogService where TContext : DbContext { /// \u003csummary\u003e /// Ensure event log context has an associated connection with input \u003csee cref=\"T\"/\u003e context. /// \u003cpara\u003eThrow \u003csee cref=\"ArgumentException\"/\u003e if input context has not same type with \u003csee cref=\"TContext\"/\u003e\u003c/para\u003e /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e /// \u003cparam name=\"context\"\u003e\u003c/param\u003e void EnsureAssociatedConnection\u003cT\u003e(T context) where T : DbContext; }\rUsage We need to register services and a DomainDbContext to use this feature.\n... using Juice.EventBus.IntegrationEventLog.EF; using Juice.EventBus.IntegrationEventLog.EF.DependencyInjection; ... services.AddIntegrationEventLog() // add integration event log services .RegisterContext\u003cDomainDbContext\u003e(schema); // migrate DB if need Call .RegisterContext\u003cDomainDbContext\u003e(schema) will register an IntegrationEventLogContext factory that mapped to specified schema and work with DomainDbContext. So IIntegrationEventLogService service can get Func\u003cDomainDbContext, IntegrationEventLogContext\u003e as a service and create an IntegrationEventLogContext instance from a DomainDbContext instance.\nThey will have associated DbConnection and can access the same transaction.\nWorking process Step by step, the process goes like this:\nThe application begins a local database transaction.\nIt then updates the state of your domain entities and inserts an event into the integration event table.\nFinally, it commits the transaction, so you get the desired atomicity and then\nYou publish the event somehow (next).\nWhen implementing the steps of publishing the events, you have these choices:\nPublish the integration event right after committing the transaction and use another local transaction to mark the events in the table as being published. Then, use the table just as an artifact to track the integration events in case of issues in the remote microservices, and perform compensatory actions based on the stored integration events.\nUse the table as a kind of queue. A separate application thread or process queries the integration event table, publishes the events to the event bus, and then uses a local transaction to mark the events as published.\n... using Juice.EventBus; using Juice.EventBus.IntegrationEventLog.EF; ... var context = scope.ServiceProvider.GetRequiredService\u003cDomainDbContext\u003e(); var eventLogService = scope.ServiceProvider.GetRequiredService\u003cIIntegrationEventLogService\u003cDomainDbContext\u003e\u003e(); eventLogService.EnsureAssociatedConnection(context); // do something with your DomainDbContext context.Add(new Content()); // create an integration event var evt = new ContentPublishedIntegrationEvent($\"Content {content.Code} was published.\"); // save DomainDbContext changes and add an integration event at the same time, in the same transaction await ResilientTransaction.New(context).ExecuteAsync(async (transaction) =\u003e { // Achieving atomicity between original catalog database operation and the IntegrationEventLog thanks to a local transaction await context.SaveChangesAsync(); await eventLogService.SaveEventAsync(evt, transaction); }); // if everything is ok then you can publish created integration event throw service bus var eventBus = scope.ServiceProvider.GetRequiredService\u003cIEventBus\u003e(); try { logger.LogInformation(\"----- Publishing integration event: {IntegrationEventId_published} from {AppName} - ({@IntegrationEvent})\", evt.Id, nameof(IntegrationEventLogTest), evt); await eventLogService.MarkEventAsInProgressAsync(evt.Id); await eventBus.PublishAsync(evt); await eventLogService.MarkEventAsPublishedAsync(evt.Id); } catch (Exception ex) { logger.LogError(ex, \"ERROR Publishing integration event: {IntegrationEventId} from {AppName} - ({@IntegrationEvent})\", evt.Id, nameof(IntegrationEventLogTest), evt); await eventLogService.MarkEventAsFailedAsync(evt.Id); }\rThe library can be accessed via Nuget:\nJuice.EventBus.IntegrationEventLog.EF Juice.EventBus.IntegrationEventLog.EF.SqlServer Juice.EventBus.IntegrationEventLog.EF.PostgreSQL",
    "description": "Versions\rlatest\r7.x\rTo communicate between services we defined an IEventBus interface with a built-in RabbitMQ broker. Please follow up Implementing event-based communication between microservices for details.",
    "tags": [],
    "title": "Event bus",
    "uri": "/core/eventbus/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rCore features \u003e \rEvent bus",
    "content": "To communicate between services we defined an IEventBus interface with a built-in RabbitMQ broker. Please follow up Implementing event-based communication between microservices for details.\nnamespace Juice.EventBus { /// \u003csummary\u003e /// Event bus /// \u003c/summary\u003e public interface IEventBus { /// \u003csummary\u003e /// Publish \u003csee cref=\"IntegrationEvent\"/\u003e to implemented broker like RabbitMQ, ServiceBus... /// \u003c/summary\u003e /// \u003cparam name=\"event\"\u003e\u003c/param\u003e Task PublishAsync(IntegrationEvent @event); /// \u003csummary\u003e /// Subscribe an \u003csee cref=\"IntegrationEvent\"/\u003e with specified \u003csee cref=\"IIntegrationEventHandler{T}\"/\u003e /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e /// \u003ctypeparam name=\"TH\"\u003e\u003c/typeparam\u003e void Subscribe\u003cT, TH\u003e(string? key = default) where T : IntegrationEvent where TH : IIntegrationEventHandler\u003cT\u003e; /// \u003csummary\u003e /// Subscribe an \u003csee cref=\"IntegrationEvent\"/\u003e with specified \u003csee cref=\"IIntegrationEventHandler{T}\"/\u003e /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e /// \u003ctypeparam name=\"TH\"\u003e\u003c/typeparam\u003e void Unsubscribe\u003cT, TH\u003e(string? key = default) where TH : IIntegrationEventHandler\u003cT\u003e where T : IntegrationEvent; } }\rRabbitMQ broker To use RabbitMQ broker as an event bus backend, we register RabbitMQEventBus services via IServiceCollection extension\n... using Juice.EventBus.RabbitMQ.DependencyInjection ... services.RegisterRabbitMQEventBus(configuration.GetSection(\"RabbitMQ\")); // OR // services.RegisterRabbitMQEventBus(configuration.GetSection(\"RabbitMQ\"), options=\u003e { // configure options here // }); // RabbitMQ options // \"RabbitMQ\": { // \"RabbitMQEnabled\": false, // \"SubscriptionClientName\": \"xunit_test\", // client name must unique for a service (not service instance) // \"RetryCount\": 5, // \"Connection\": \"your_rabbitmq_host\", // \"Port\": 5672, // \"VirtualHost\": null, // \"UserName\": null, // \"Password\": null // }\rThe library can be accessed via Nuget:\nJuice.EventBus.RabbitMQ Implementation IntegrationEvent You can define your integration event that inherit IntegrationEvent record then publish throw IEventBus\nusing Juice.EventBus; public record ContentPublishedIntegrationEvent : IntegrationEvent { public ContentPublishedIntegrationEvent(string message) { Message = message; } public string Message { get; set; } }\r... using Juice.EventBus; ... await eventBus.PublishAsync(new ContentPublishedIntegrationEvent($\"Hello\"));\rThe library can be accessed via Nuget:\nJuice.EventBus IntegrationEventHandler Someone will implement an integration handler from IIntegrationEventHandler interface in other app to handle your integration event for their purposes.\nFor example: a handler that print received message and event time.\n... using Juice.EventBus; ... public class ContentPublishedIntegrationEventHandler : IIntegrationEventHandler\u003cContentPublishedIntegrationEvent\u003e { private ILogger _logger; public ContentPublishedIntegrationEventHandler(ILogger\u003cContentPublishedIntegrationEventHandler\u003e logger) { _logger = logger; } public async Task HandleAsync(ContentPublishedIntegrationEvent @event) { await Task.Yield(); _logger.LogInformation(\"[X] Received {0} at {1}\", @event.Message, @event.CreationDate); } }\rThen register into DI and subscribe event\n// configure services services.AddTransient\u003cContentPublishedIntegrationEventHandler\u003e(); ... // configure WebApplication var eventBus = app.Services.GetRequiredService\u003cIEventBus\u003e(); eventBus.Subscribe\u003cContentPublishedIntegrationEvent, ContentPublishedIntegrationEventHandler\u003e();\rThe library can be accessed via Nuget:\nJuice.EventBus IntegrationEventLog It is a part of balanced approach for atomicity and resiliency when publishing to the event bus. You can follow Designing atomicity and resiliency when publishing to the event bus topic for more information. We provide IIntegrationEventLogService interface with an implementation for EF backend use SQLServer or PostgreSQL.\npublic interface IIntegrationEventLogService : IDisposable { IntegrationEventLogContext LogContext { get; } // Use to process pending events Task\u003cIEnumerable\u003cIntegrationEventLogEntry\u003e\u003e RetrieveEventLogsPendingToPublishAsync(Guid transactionId); // Save an integration event within a same transaction with domain DBContext Task SaveEventAsync(IntegrationEvent @event, IDbContextTransaction transaction); // Change event state after publish it to the service bus Task MarkEventAsPublishedAsync(Guid eventId); // Change event state before publish it to the service bus Task MarkEventAsInProgressAsync(Guid eventId); // Change event state on failure publising Task MarkEventAsFailedAsync(Guid eventId); } public interface IIntegrationEventLogService\u003cout TContext\u003e : IIntegrationEventLogService where TContext : DbContext { /// \u003csummary\u003e /// Ensure event log context has an associated connection with input \u003csee cref=\"T\"/\u003e context. /// \u003cpara\u003eThrow \u003csee cref=\"ArgumentException\"/\u003e if input context has not same type with \u003csee cref=\"TContext\"/\u003e\u003c/para\u003e /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e /// \u003cparam name=\"context\"\u003e\u003c/param\u003e void EnsureAssociatedConnection\u003cT\u003e(T context) where T : DbContext; }\rUsage We need to register services and a DomainDbContext to use this feature.\n... using Juice.EventBus.IntegrationEventLog.EF; using Juice.EventBus.IntegrationEventLog.EF.DependencyInjection; ... services.AddIntegrationEventLog() // add integration event log services .RegisterContext\u003cDomainDbContext\u003e(schema); // migrate DB if need Call .RegisterContext\u003cDomainDbContext\u003e(schema) will register an IntegrationEventLogContext factory that mapped to specified schema and work with DomainDbContext. So IIntegrationEventLogService service can get Func\u003cDomainDbContext, IntegrationEventLogContext\u003e as a service and create an IntegrationEventLogContext instance from a DomainDbContext instance.\nThey will have associated DbConnection and can access the same transaction.\nWorking process Step by step, the process goes like this:\nThe application begins a local database transaction.\nIt then updates the state of your domain entities and inserts an event into the integration event table.\nFinally, it commits the transaction, so you get the desired atomicity and then\nYou publish the event somehow (next).\nWhen implementing the steps of publishing the events, you have these choices:\nPublish the integration event right after committing the transaction and use another local transaction to mark the events in the table as being published. Then, use the table just as an artifact to track the integration events in case of issues in the remote microservices, and perform compensatory actions based on the stored integration events.\nUse the table as a kind of queue. A separate application thread or process queries the integration event table, publishes the events to the event bus, and then uses a local transaction to mark the events as published.\n... using Juice.EventBus; using Juice.EventBus.IntegrationEventLog.EF; ... var context = scope.ServiceProvider.GetRequiredService\u003cDomainDbContext\u003e(); var eventLogService = scope.ServiceProvider.GetRequiredService\u003cIIntegrationEventLogService\u003cDomainDbContext\u003e\u003e(); eventLogService.EnsureAssociatedConnection(context); // do something with your DomainDbContext context.Add(new Content()); // create an integration event var evt = new ContentPublishedIntegrationEvent($\"Content {content.Code} was published.\"); // save DomainDbContext changes and add an integration event at the same time, in the same transaction await ResilientTransaction.New(context).ExecuteAsync(async (transaction) =\u003e { // Achieving atomicity between original catalog database operation and the IntegrationEventLog thanks to a local transaction await context.SaveChangesAsync(); await eventLogService.SaveEventAsync(evt, transaction); }); // if everything is ok then you can publish created integration event throw service bus var eventBus = scope.ServiceProvider.GetRequiredService\u003cIEventBus\u003e(); try { logger.LogInformation(\"----- Publishing integration event: {IntegrationEventId_published} from {AppName} - ({@IntegrationEvent})\", evt.Id, nameof(IntegrationEventLogTest), evt); await eventLogService.MarkEventAsInProgressAsync(evt.Id); await eventBus.PublishAsync(evt); await eventLogService.MarkEventAsPublishedAsync(evt.Id); } catch (Exception ex) { logger.LogError(ex, \"ERROR Publishing integration event: {IntegrationEventId} from {AppName} - ({@IntegrationEvent})\", evt.Id, nameof(IntegrationEventLogTest), evt); await eventLogService.MarkEventAsFailedAsync(evt.Id); }\rThe library can be accessed via Nuget:\nJuice.EventBus.IntegrationEventLog.EF Juice.EventBus.IntegrationEventLog.EF.SqlServer Juice.EventBus.IntegrationEventLog.EF.PostgreSQL",
    "description": "To communicate between services we defined an IEventBus interface with a built-in RabbitMQ broker. Please follow up Implementing event-based communication between microservices for details.\nnamespace Juice.EventBus { /// \u003csummary\u003e /// Event bus /// \u003c/summary\u003e public interface IEventBus { /// \u003csummary\u003e /// Publish \u003csee cref=\"IntegrationEvent\"/\u003e to implemented broker like RabbitMQ, ServiceBus... /// \u003c/summary\u003e /// \u003cparam name=\"event\"\u003e\u003c/param\u003e Task PublishAsync(IntegrationEvent @event); /// \u003csummary\u003e /// Subscribe an \u003csee cref=\"IntegrationEvent\"/\u003e with specified \u003csee cref=\"IIntegrationEventHandler{T}\"/\u003e /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e /// \u003ctypeparam name=\"TH\"\u003e\u003c/typeparam\u003e void Subscribe\u003cT, TH\u003e(string? key = default) where T : IntegrationEvent where TH : IIntegrationEventHandler\u003cT\u003e; /// \u003csummary\u003e /// Subscribe an \u003csee cref=\"IntegrationEvent\"/\u003e with specified \u003csee cref=\"IIntegrationEventHandler{T}\"/\u003e /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e /// \u003ctypeparam name=\"TH\"\u003e\u003c/typeparam\u003e void Unsubscribe\u003cT, TH\u003e(string? key = default) where TH : IIntegrationEventHandler\u003cT\u003e where T : IntegrationEvent; } }\rRabbitMQ broker To use RabbitMQ broker as an event bus backend, we register RabbitMQEventBus services via IServiceCollection extension",
    "tags": [],
    "title": "Event bus",
    "uri": "/core/eventbus/v7.x/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rCore features",
    "content": "DbContextBase We resolved Audit, UnitOfWork and dynamic schema problems with an abstract DbContext that implemented these interfaces:\nIAuditableDbContext IUnitOfWork IScehmaDbContext We’ll explain these interfaces below, but remember to call ConfigureServices( serviceProvider ) for your legacy DbContext in two ways:\nInside constructor // call inside constructor public TimerDbContext(IServiceProvider serviceProvider, DbContextOptions\u003cTimerDbContext\u003e options) : base(options) { ConfigureServices(serviceProvider); }\rOr inside context factory if you are using pooled DbContext public class TimerDbContextScopedFactory : IDbContextFactory\u003cTimerDbContext\u003e { private readonly IDbContextFactory\u003cTimerDbContext\u003e _pooledFactory; private readonly IServiceProvider _serviceProvider; public TimerDbContextScopedFactory( IDbContextFactory\u003cTimerDbContext\u003e pooledFactory, IServiceProvider serviceProvider) { _pooledFactory = pooledFactory; _serviceProvider = serviceProvider; } public TimerDbContext CreateDbContext() { var context = _pooledFactory.CreateDbContext(); context.ConfigureServices(_serviceProvider); return context; } }\rThen register PooledDbContext\nservices.AddPooledDbContextFactory\u003cTimerDbContext\u003e((serviceProvider, options) =\u003e { // configure DB options }); services.AddScoped\u003cTimerDbContextScopedFactory\u003e(); services.AddScoped(sp =\u003e sp.GetRequiredService\u003cTimerDbContextScopedFactory\u003e().CreateDbContext());\rDbOptions The abstract class DbOptions contains:\nDatabaseProvider ConnectionName Schema JsonPropertyBehavior: (UpdageCHANGES, UpdateALL) The DbOptions\u003cT\u003e class derived from DbOptions will specify a DbContext type that it is used for.\nInterfaces IModificationInfo: the inheritance model will be updated the ModifiedUser, ModifiedDate every changes ICreationInfo: the inheritance model will be updated the CreatedUser, CreatedDate on creation IRemovable: the inheritance model will be updated the RemovedUser, RemovedDate or RestoredUser, RestoredDate depend on IsRemoved value changed IAuditable: the inheritance model will be fired data AuditEvent every changes Attributes Notice: the class that has this attribue will be fired DataEvent on specified changes (Created, Modified, ) Working process Database context classes derived from DbContextBase will:\nTry configure User infomation by get from HttpContext if exists Set the _options if there is an instance of DbOptions\u003cYourDbContext\u003e was registered Set the Schema if it is specified in _options Before call SaveChanges or SaveChangesAsync of original DbContext class Track changes and update to PendingAuditEntries Set basic audit info (CreatedUser/ModifiedUser/CreatedDate/ModifiedDate) into ICreationInfo and IModificationInfo entity model Call base.SaveChanges() or base.SaveChangesAsync() After call base methods Send domain events collected from entities that inherit IAggregrateRoot interface Dispatch PendingAuditEntries to notice DataEvent through MediatR IAuditableDbContext We provide IAuditableDbContext interface and its extensions to track changes, update audit columns, and finally, dispatch data change events.\npublic interface IAuditableDbContext { List\u003cAuditEntry\u003e? PendingAuditEntries { get; } string? User { get; } }\rDatabase context classes derived from IAuditableDbContext will:\nSet User info when init context instance. Before call SaveChanges or SaveChangesAsync of original DbContext class Track changes and update to PendingAuditEntries Set basic audit info (CreatedUser/ModifiedUser/CreatedDate/ModifiedDate) into auditable entity model Dispatch PendingAuditEntries to notice DataEvent through MediatR after called SaveChanges or SaveChangesAsync, so you can handle DataEvent to process audit records. There are two ways to designate an entity type as auditable:\nInherit from IAuditable interface using Juice.Domain; public class Content: IAuditable{ ... }\rUse fluent API IsAuditable() If your entity does not contain basic audit info properties (CreatedUser/ModifiedUser/CreatedDate/ModifiedDate) you can not access them but these columns are still available in your DB table.\nusing Juice.EF.Extensions; public class ContentDbContext: DbContextBase{ ... protected override void ConfigureModel(ModelBuilder modelBuilder) { modelBuilder.Entity\u003cContent\u003e(options =\u003e { options.ToTable(nameof(Content), Schema); options.IsAuditable(); }); } }\rYou can see Audit service for more details.\nISchemaDbContext This interface has only one purpose which is support to migrating the DBContext with an optional schema. After running Add-Migration command, you must modify the generated migration file to customize the schema.\n... using Juice.EF; ... public partial class InitEventLog : Migration { private readonly ISchemaDbContext _schema; public InitEventLog() { } // add one more constructor to inject ISchemaDbContext service public InitEventLog(ISchemaDbContext schema) { _schema = schema; } protected override void Up(MigrationBuilder migrationBuilder) { migrationBuilder.EnsureSchema( name: _schema.Schema); migrationBuilder.CreateTable( name: \"IntegrationEventLog\", schema: _schema.Schema, columns: table =\u003e new ...\rYou also need to replace the original IMigrationsAssembly with DbSchemaAwareMigrationAssembly in DbContextOptionsBuilder\n... using Juice.EF.Migrations; ... services.AddDbContext\u003cIntegrationEventLogContext\u003e(options =\u003e { ... options.ReplaceService\u003cIMigrationsAssembly, DbSchemaAwareMigrationAssembly\u003e(); });\rIUnitOfWork You can read more about Unit of Work before continue. We define an IUnitOfWork interface to easy to work with DbContext transaction.\npublic interface IUnitOfWork { IDbContextTransaction? GetCurrentTransaction(); bool HasActiveTransaction { get; } Task\u003cIDbContextTransaction?\u003e BeginTransactionAsync(); Task CommitTransactionAsync(IDbContextTransaction transaction); void RollbackTransaction(); }\rMultiTenantDbContext This abstract class has similar behaviors to DbContextBase above but added TenantInfo so we can pass tenant to DB or filter data by tenant. It is a bit different from the official MultiTenantDbContext from Finbuckle: it still works even though TenantInfo can not be resolved.\nCross-tenant entity type Sometimes we maybe want to have entities that can be shared from the Root tenant and accessible to other tenants (Ex: settings, users…). So we provide an extension to describe an entity as cross-tenant.\n// IdentityDbContext.cs using Juice.MultiTenant.EF.Extensions; ... protected override void OnModelCreating(ModelBuilder builder) { base.OnModelCreating(builder); // configure any type that has Multitenant attribute builder.ConfigureMultiTenant(); // describe that User is cross tenant builder.Entity\u003cUserIdentity\u003e().ToTable(TableConsts.IdentityUsers).IsCrossTenant(); ... }\rWhat exactly does it do?\nMarks the entity with the shadown property TenantId, but it is not required Entity settings to filter data that does not have a TenantId value or a TenantId value that matches TenantInfo Some special settings affect to Identity entity types IdentityUser\u003c\u003e: replace the index of column NormalizedUserName with the new index associated with TenantId IdentityRole\u003c\u003e: replace the index of column NormalizedName with the new index associated with TenantId IdentityUserLogin\u003c\u003e: replace the primary key with new Id column and then add an combined index of LoginProvider, ProviderKey and TenantId NOTE\nBe careful while using cross-tenant entities Consider using the Per-tenant authentication convention to specify who can access cross-tenant resources The library can be accessed via Nuget:\nJuice.EF Juice.EF.MultiTenant",
    "description": "DbContextBase We resolved Audit, UnitOfWork and dynamic schema problems with an abstract DbContext that implemented these interfaces:\nIAuditableDbContext IUnitOfWork IScehmaDbContext We’ll explain these interfaces below, but remember to call ConfigureServices( serviceProvider ) for your legacy DbContext in two ways:\nInside constructor // call inside constructor public TimerDbContext(IServiceProvider serviceProvider, DbContextOptions\u003cTimerDbContext\u003e options) : base(options) { ConfigureServices(serviceProvider); }\rOr inside context factory if you are using pooled DbContext public class TimerDbContextScopedFactory : IDbContextFactory\u003cTimerDbContext\u003e { private readonly IDbContextFactory\u003cTimerDbContext\u003e _pooledFactory; private readonly IServiceProvider _serviceProvider; public TimerDbContextScopedFactory( IDbContextFactory\u003cTimerDbContext\u003e pooledFactory, IServiceProvider serviceProvider) { _pooledFactory = pooledFactory; _serviceProvider = serviceProvider; } public TimerDbContext CreateDbContext() { var context = _pooledFactory.CreateDbContext(); context.ConfigureServices(_serviceProvider); return context; } }\rThen register PooledDbContext",
    "tags": [],
    "title": "Entity framework",
    "uri": "/core/entityframework/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rCore features",
    "content": "Integration event service In the IntegrationEventLog section, we talked about atomicity and resiliency when publishing to the event bus, followed by each step of the process. In this section, we will package the steps of publishing events and updating event states into IIntegrationEventService service, and then combine them with MediatR behavior for transaction processing.\npublic interface IIntegrationEventService { Task PublishEventsThroughEventBusAsync(Guid transactionId); Task AddAndSaveEventAsync(IntegrationEvent evt); } public interface IIntegrationEventService\u003cout TContext\u003e : IIntegrationEventService where TContext : DbContext, IUnitOfWork { TContext DomainContext { get; } /// \u003csummary\u003e /// Use specified transaction when working with transient DbContext /// \u003c/summary\u003e /// \u003cparam name=\"evt\"\u003e\u003c/param\u003e /// \u003cparam name=\"transaction\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e Task AddAndSaveEventAsync(IntegrationEvent evt, IDbContextTransaction transaction); }\rNow the process steps will look like this:\n... using Juice.Integrations.EventBus; ... var context = scope.ServiceProvider.GetRequiredService\u003cDomainDbContext\u003e(); var integrationEventService = scope.ServiceProvider.GetRequiredService\u003cIIntegrationEventService\u003cDomainDbContext\u003e\u003e(); // do something with your DomainDbContext context.Add(new Content()); // create an integration event var evt = new ContentPublishedIntegrationEvent($\"Content {content.Code} was published.\"); // save DomainDbContext changes and add an integration event at the same time, in the same transaction await ResilientTransaction.New(context).ExecuteAsync(async (transaction) =\u003e { // Achieving atomicity between original catalog database operation and the IntegrationEventLog thanks to a local transaction await context.SaveChangesAsync(); await integrationEventService.AddAndSaveEventAsync(evt); // commit transaction await context.CommitTransactionAsync(transaction); // if everything is ok then you can publish created integration event throw service bus await integrationEventService.PublishEventsThroughEventBusAsync(transaction.TransactionId); });\rNOTE: to use this pattern, your DomainDbContext must implement IUnitOfWork interface.\nThe library can be accessed via Nuget:\nJuice.Integrations Transaction behavior One more step to streamline the process in the section above when integrating with MediatR. We have implemented an abstraction class to handle the transaction step by step:\nBegin a resilient transaction Process IRequest command Commit transaction (auto add and save integration events by UnitOfWork pattern) Publish pending events through event bus Return processed command result You need to implement TransactionBehavior\u003cTRequest, TResponse, TContext\u003e for your request and DbContext like this:\nusing Juice.Integrations.EventBus; using Juice.Integrations.MediatR.Behaviors; ... internal class TimerTransactionBehavior\u003cT, R\u003e : TransactionBehavior\u003cT, R, TimerDbContext\u003e where T : IRequest\u003cR\u003e { public TimerTransactionBehavior(TimerDbContext dbContext, IIntegrationEventService\u003cTimerDbContext\u003e integrationEventService, ILogger\u003cTimerTransactionBehavior\u003cT, R\u003e\u003e logger) : base(dbContext, integrationEventService, logger) { } }\rThen register as a MediatR behavior\nservices.AddScoped(typeof(IPipelineBehavior\u003cCreateTimerCommand, TimerRequest\u003e), typeof(TimerTransactionBehavior\u003cCreateTimerCommand, TimerRequest\u003e));\rTo understand this section, please read more about using UnitOfWork and MediatR.\nThe library can be accessed via Nuget:\nJuice.Integrations",
    "description": "Integration event service In the IntegrationEventLog section, we talked about atomicity and resiliency when publishing to the event bus, followed by each step of the process. In this section, we will package the steps of publishing events and updating event states into IIntegrationEventService service, and then combine them with MediatR behavior for transaction processing.\npublic interface IIntegrationEventService { Task PublishEventsThroughEventBusAsync(Guid transactionId); Task AddAndSaveEventAsync(IntegrationEvent evt); } public interface IIntegrationEventService\u003cout TContext\u003e : IIntegrationEventService where TContext : DbContext, IUnitOfWork { TContext DomainContext { get; } /// \u003csummary\u003e /// Use specified transaction when working with transient DbContext /// \u003c/summary\u003e /// \u003cparam name=\"evt\"\u003e\u003c/param\u003e /// \u003cparam name=\"transaction\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e Task AddAndSaveEventAsync(IntegrationEvent evt, IDbContextTransaction transaction); }\rNow the process steps will look like this:",
    "tags": [],
    "title": "Integration service",
    "uri": "/core/integration/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rQuickstarts",
    "content": "If you are completed implementing your app with all necessary functions, we will only be interested in integrating with other services here.\nBuild your minimal app based on implemented domain features Integrate with the authentication/authorization services Integration testing with an event bus like RabbitMQ or another service bus Again, we will accept that there is no standard layout for microservices, it depends on the situation and purpose of the service. It may be complex or simple like the images below.\nComplex process Simple process",
    "description": "If you are completed implementing your app with all necessary functions, we will only be interested in integrating with other services here.\nBuild your minimal app based on implemented domain features Integrate with the authentication/authorization services Integration testing with an event bus like RabbitMQ or another service bus Again, we will accept that there is no standard layout for microservices, it depends on the situation and purpose of the service. It may be complex or simple like the images below.",
    "tags": [],
    "title": "Microservice",
    "uri": "/quickstart/microservice/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rQuickstarts",
    "content": "We will only be interested in building application here, there are two options:\nBuild your app by register services and configure application manually Use Modular to register module’s services and configure modules.",
    "description": "We will only be interested in building application here, there are two options:\nBuild your app by register services and configure application manually Use Modular to register module’s services and configure modules.",
    "tags": [],
    "title": "Monolithic",
    "uri": "/quickstart/mono/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rCore features",
    "content": "Dependency Injection\nLogging\nPriority\nCI-Ignore",
    "description": "Dependency Injection\nLogging\nPriority\nCI-Ignore",
    "tags": [],
    "title": "xUnit",
    "uri": "/core/xunit/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rCore features",
    "content": "MultiTenant This core feature is useful to verify other core features that we have built because it is developed as a microservice. It’s integrated with Finbuckle to identity the tenant. We provide multiple choices for tenant data store:\nFile store EFCore store gRPC store We also provide the gRPC API to manage tenant information and tenant settings, so MultiTenant itself is a service with the full implementation of:\nMultiTenant DBContext UnitOfWork pattern Audit gRPC API DDD/CQRS and Domain Events pattern Integration with event bus Per-tenant configuration/options xUnit helper To use multi-tenant, we must register services with Tenant type\nvar tenantBuilder = builder.Services // default Finbuckle services .AddMultiTenant\u003cTenant\u003e(options =\u003e { // configure tenant options }) .WithBasePathStrategy(options =\u003e options.RebaseAspNetCorePathBase = true) // AND/OR other strategies ;\rAfter that, we have 2 choices:\nUse multi-tenant as a separate serice by building a multi-tenant server and use gRPC client to get tenant information. So we will register services for tenant host inside tenant microservice.\n... using Juice.MultiTenant.Api.DependencyInjection; ... tenantBuilder.ConfigureTenantHost(builder.Configuration, options =\u003e { options.DatabaseProvider = \"PostgreSQL\"; options.ConnectionName = \"PostgreConnection\"; options.Schema = \"App\"; });\rThen register services for tenant client inside other microservices.\n... using Juice.MultiTenant.Grpc.Finbuckle.DependencyInjection; ... tenantBuilder.ConfigureTenantClient(builder.Configuration, builder.Environment.EnvironmentName);\rUse multi-tenant service directly. Default EF store build ... using Juice.MultiTenant.EF.DependencyInjection; ... tenantBuilder.ConfigureTenantEFDirectly(builder.Configuration, options =\u003e { options.DatabaseProvider = \"PostgreSQL\"; options.ConnectionName = \"PostgreConnection\"; options.Schema = \"App\"; }, builder.Environment.EnvironmentName);\rOr manually build tenant service with multiple store options. ... using Juice.MultiTenant.Finbuckle.DependencyInjection; ... tenantBuilder.JuiceIntegration() .WithGprcStore(tenantGrpcEndpoint) .WithDistributedCacheStore() // .WithEFStore(...) // you can add many stores at the same time ;\rPer-tenant Authentication We provide a custom WithPerTenantAuthenticationConventions extension beside the original WithPerTenantAuthenticationConventions from Finbuckle. It allows you to handle cross-tenant authorization yourself.\nusing Juice.MultiTenant.AspNetCore; ... services .AddMultiTenant() .WithBasePathStrategy(options =\u003e options.RebaseAspNetCorePathBase = true) .ConfigureTenantEFDirectly(configuration, options =\u003e { options.DatabaseProvider = \"PostgreSQL\"; options.ConnectionName = \"TenantDbConnection\"; options.Schema = \"App\"; }, environment.EnvironmentName) .WithPerTenantOptions\u003cOpenIdConnectOptions\u003e((options, tc) =\u003e { options.Authority = authority + $\"/{tc.Identifier}\"; }) .WithPerTenantAuthenticationCore() // it's required .WithPerTenantAuthenticationConventions(crossTenantAuthorize: (authTenant, currentTenant, principal) =\u003e authTenant == null // root tenant \u0026\u0026 (principal?.Identity?.IsAuthenticated ?? false) // authenticated \u0026\u0026 principal.IsInRole(\"admin\")) .WithRemoteAuthenticationCallbackStrategy() ;\rThe library can be accessed via Nuget and npmjs:\nJuice.MultiTenant Juice.MultiTenant.AspNetCore Juice.MultiTenant.EF Juice.MultiTenant.EF.SqlServer Juice.MultiTenant.EF.PostgreSQL Juice.MultiTenant.Api.Contracts Juice.MultiTenant.Api Juice.MultiTenant.Grpc @juice-js/tenants MultiTenant DBContext Please follow up on Data Isolation with Entity Framework Core to understand this section.\nWe usually have two options for storing per-tenant application data:\nSeparate DB with different DB connection strings, it can be done by per-tenant setting Shared DB with an extra TenantId column to determine tenant data In the second way, we will create a TenantDbContext that implement IMultiTenantDbContext interface. So we provide a MultiTenantDbContext abstraction class that implement these interfaces:\nISchemaDbContext IAuditableDbContext IUnitOfWork IMultiTenantDbContext You can inherit MultiTenantDbContext abstraction and mark your entity IsMultiTenant(), and/or IsAuditable().\nusing Juice.EF.Extensions; using Juice.EF.MultiTenant; ... public class TenantContentDbContext : MultiTenantDbContext { public DbSet\u003cTenantContent\u003e TenantContents { get; set; } public TenantContentDbContext(IServiceProvider serviceProvider, DbContextOptions options) : base(options) { ConfigureServices(serviceProvider); } protected override void ConfigureModel(ModelBuilder modelBuilder) { modelBuilder.Entity\u003cTenantContent\u003e(options =\u003e { options.ToTable(nameof(TenantContent), Schema); options.IsMultiTenant(); options.IsAuditable(); }); } }\rOr using the [MultiTenant] attribute in entity class\nusing Finbuckle.MultiTenant; [MultiTenant] public class TenantContent { ... }\rSee MultiTenantDbContext for more information.\nThe library can be accessed via Nuget:\nJuice.EF.MultiTenant",
    "description": "MultiTenant This core feature is useful to verify other core features that we have built because it is developed as a microservice. It’s integrated with Finbuckle to identity the tenant. We provide multiple choices for tenant data store:\nFile store EFCore store gRPC store We also provide the gRPC API to manage tenant information and tenant settings, so MultiTenant itself is a service with the full implementation of:\nMultiTenant DBContext UnitOfWork pattern Audit gRPC API DDD/CQRS and Domain Events pattern Integration with event bus Per-tenant configuration/options xUnit helper To use multi-tenant, we must register services with Tenant type",
    "tags": [],
    "title": "Multi-tenant",
    "uri": "/core/multitenant/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rCore features",
    "content": "This small feature is useful for build a monolithic application from multiple separated features. Developers can register services and configure their modules by themselves.\nFirstly, you need to implement the class that inherits from ModuleStartup for your features.\nusing Juice.Modular; ... namespace Juice.Test { [Feature(Required = true)] public class TestModuleStartup : ModuleStartup{ // override ConfigureServices public override void ConfigureServices(IServiceCollection services, IMvcBuilder mvc, IWebHostEnvironment env, IConfigurationRoot configuration) { // configure your services } // override Configure public override void Configure(IApplicationBuilder app, IEndpointRouteBuilder routes, IWebHostEnvironment env) { // configure application pipeline } // override OnShutdown public override void OnShutdown(IServiceProvider serviceProvider, IWebHostEnvironment env) { // release resources } } }\rThe Feature attribute’s arguments:\nRequired: specify this feature is required and will start automatically\nName: specify your feature’s name. If it’s not defined, the default name will be used. The default name will be namespace then replace the “.” with “_”.\nEx: Your namespace is Juice.Test so the feature name will be Juice_Test by default.\nDescription: describe your feature\nDependencies: an array of dependent features\nIncompatibleFeatures: an array of incompatible features. The application will throw an exception on startup if incompatible features are registered, so you must try to solve.\nThen in your Program.cs\nusing Juice.Modular; ... var builder = WebApplication.CreateBuilder(args); builder.AddDiscoveredModules(); ... var app = builder.Build(); // customize application's middlewares order // app.UseMultiTenant(); // app.UseRouting(); ... app.ConfigureDiscoveredModules(); ... app.Run();",
    "description": "This small feature is useful for build a monolithic application from multiple separated features. Developers can register services and configure their modules by themselves.\nFirstly, you need to implement the class that inherits from ModuleStartup for your features.\nusing Juice.Modular; ... namespace Juice.Test { [Feature(Required = true)] public class TestModuleStartup : ModuleStartup{ // override ConfigureServices public override void ConfigureServices(IServiceCollection services, IMvcBuilder mvc, IWebHostEnvironment env, IConfigurationRoot configuration) { // configure your services } // override Configure public override void Configure(IApplicationBuilder app, IEndpointRouteBuilder routes, IWebHostEnvironment env) { // configure application pipeline } // override OnShutdown public override void OnShutdown(IServiceProvider serviceProvider, IWebHostEnvironment env) { // release resources } } }\rThe Feature attribute’s arguments:",
    "tags": [],
    "title": "Modular",
    "uri": "/core/modular/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rWorkflow",
    "content": "Different businesses do not have the same work processes, even within an organization there are different work processes. Therefore, there are many workflow tools invented to meet the needs.\nPurpose Lightweigh workflow engine Bpmn/ Yaml compatible Sub-workflow support Works with microservices Concept Audit process Workflow Subject content\nsubject Subject content\nsubject Subject content",
    "description": "Different businesses do not have the same work processes, even within an organization there are different work processes. Therefore, there are many workflow tools invented to meet the needs.\nPurpose Lightweigh workflow engine Bpmn/ Yaml compatible Sub-workflow support Works with microservices Concept Audit process Workflow Subject content\nsubject Subject content\nsubject Subject content",
    "tags": [],
    "title": "Overview",
    "uri": "/workflow/overview/index.html"
  },
  {
    "breadcrumb": "Juice's documentation \u003e \rBackground service",
    "content": "Purposes Operate background services remotely (Start, Stop, Invoke Job…) Load background service as as plugin dynamically Monitor service status Custom service logging Usage We provide ServiceManager service to manage and operate IManagedService instances and Web API to access it.\nBackground service sequence diagram using Juice.BgService.Management; using Juice.BgService.Extensions.Logging; using Juice.Extensions.Options.DependencyInjection; ... var builder = WebApplication.CreateBuilder(args); // see Logging section builder.Logging.AddBgServiceFileLogger(builder.Configuration.GetSection(\"Logging:File\")); builder.Services.AddBgService(builder.Configuration.GetSection(\"BackgroundService\")) .UseFileStore(builder.Configuration.GetSection(\"File\")); // optional use separated appsettings file for background service file store. builder.SeparateStoreFile(\"Store\"); var pluginPaths = new string[] { // plugin absolute paths }; // Optional plugins builder.Services.AddPlugins(options =\u003e { options.AbsolutePaths = pluginPaths; options.ConfigureSharedServices = (services, sp) =\u003e { }; }); // required for web api builder.Services.AddControllers(); ... var app = builder.Build(); ... app.MapControllers();\rImplementation We provide Juice.BgService.ServiceBase that contains a number of abstract services that you can inherit.\nBackgroundService This abstract service contains only basic methods that can be managed by ServiceManager, so you can implement anything in your service by overriding the ExecuteAsync() method.\nScheduledService This abstract service is processed according to the schedule options, so you can schedule something to be done by overriding the InvokeAsync() method.\nThe ScheduledServiceOptions has Frequencies options to scheduling a task (we can add one or more Frequency):\nRunOnStartup: if false, you must start service manually. Occurs: (Daily, Weekly, Monthly, Once) Daily: describes daily schedule if the Occurs is set to Daily RecursEvery: service will recurs after number of days OccursOnceAt: if specified, the InvokeAsync method will be called once at specified time after every RecursEvery day(s). OccursEvery: if no OccursOnceAt is specified, the InvokeAsync method will be called after every specified interval (30s by default), in the working time and recurs after every RecursEvery day(s). StartingAt: describes the start time of work during the day Duration: describes working time of the day Weekly: describes weekly schedule if the Occurs is set to Weekly. It is almost the same as the Daily frequency above but has differences: RecursEvery: service will recurs after number of weeks OnDays: describes the days of the week on which the service will execute StartOfWeek: describes the first day of the week Ex: If the schedule is { RecursEvery: 2, OnDays: [Mon, Wed, Fri], StartOfWeek: Tue } and today is Saturday of the week of execution, the next execution will be next Monday. After that, the service will await for 2 weeks. Monthly: describes monthly schedule if the Occurs is set to Monthly. It is almost the same as the Daily frequency above but has more options: RecursEvery: service will recurs after number of months OnDay: service will only be performed on this day of the month (optional) DayOfWeek: service will only be performed on this day of the week, combined with On to specify the day in month (Ex: the third Friday of month) On: (First, Second, Third, Fourth, Last) describes the week in month SpecialDay: (Day, Weekday, Weekend), combined with On to specify the special day in month (Ex: the last weekend of month) FileWatcherService This abstract service will monitor the file changes and invoke these methods:\nOnFileRenamedAsync OnFileDeletedAsync OnFileReadyAsync You will override these method to handle yourself.\nService repository We are implemented a default service repository based on configuration. You can call UseFileStore(configurationSection) to use it, or implement a repository yourself.\nThe sample source code is available on github.\nThe library can be accessed via Nuget:\nJuice.BgService Juice.BgService.ServiceBase Juice.BgService.Api",
    "description": "Purposes Operate background services remotely (Start, Stop, Invoke Job…) Load background service as as plugin dynamically Monitor service status Custom service logging Usage We provide ServiceManager service to manage and operate IManagedService instances and Web API to access it.\nBackground service sequence diagram using Juice.BgService.Management; using Juice.BgService.Extensions.Logging; using Juice.Extensions.Options.DependencyInjection; ... var builder = WebApplication.CreateBuilder(args); // see Logging section builder.Logging.AddBgServiceFileLogger(builder.Configuration.GetSection(\"Logging:File\")); builder.Services.AddBgService(builder.Configuration.GetSection(\"BackgroundService\")) .UseFileStore(builder.Configuration.GetSection(\"File\")); // optional use separated appsettings file for background service file store. builder.SeparateStoreFile(\"Store\"); var pluginPaths = new string[] { // plugin absolute paths }; // Optional plugins builder.Services.AddPlugins(options =\u003e { options.AbsolutePaths = pluginPaths; options.ConfigureSharedServices = (services, sp) =\u003e { }; }); // required for web api builder.Services.AddControllers(); ... var app = builder.Build(); ... app.MapControllers();\rImplementation We provide Juice.BgService.ServiceBase that contains a number of abstract services that you can inherit.",
    "tags": [],
    "title": "Manageable services",
    "uri": "/bg_service/managed_service/index.html"
  },
  {
    "breadcrumb": "Juice's documentation",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "breadcrumb": "Juice's documentation",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]

<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Messaging :: Juice's documentation</title><link>https://juice-docs.creatorflow.io/core/messaging/index.html</link><description>Juice v9 unifies all message types under a single IMessage hierarchy and introduces a MessagingBuilder entry point that composes the outbox, delivery, idempotency, and broker layers with a single services.AddMessaging() call.
IMessage Hierarchy Every message type in Juice v9 — MediatR commands, domain events, and integration events — implements IMessage, giving them a shared identity (MessageId, CreatedAt, TenantId).
IMessage├── MessageId : Guid├── CreatedAt : DateTimeOffset└── TenantId : string?IEvent : IMessage└── EventName : stringIIntegrationEvent : IEvent ← required only on the CONSUMING side└── (marker — enables dispatcher routing)MessageBase (abstract record) : IMessage└── MessageId = Guid.NewGuid(), CreatedAt = UtcNow (defaults)IntegrationEvent (abstract record) : MessageBase, IIntegrationEvent└── EventName → GetType().Name (default) ← optional to customizing the routing key on the PRODUCER sidePublish vs. Consume roles Role Type required Reason Publishing (outbox staging) Any IMessage Outbox accepts any message including plain domain events Consuming (broker dispatch) Must implement IIntegrationEvent IntegrationEventDispatcher uses EventName + type registry to deserialize and route from raw bytes Key insight: A plain domain event (IMessage) can be published and delivered through the outbox without ever implementing IIntegrationEvent if you do not want to customizing the event name. Only services that need to receive it via broker infrastructure must use IIntegrationEvent.</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 19 Feb 2026 00:00:00 +0000</lastBuildDate><atom:link href="https://juice-docs.creatorflow.io/core/messaging/index.xml" rel="self" type="application/rss+xml"/><item><title>Outbox Setup</title><link>https://juice-docs.creatorflow.io/core/messaging/outbox/index.html</link><pubDate>Thu, 19 Feb 2026 00:00:00 +0000</pubDate><guid>https://juice-docs.creatorflow.io/core/messaging/outbox/index.html</guid><description>Overview The Outbox pattern ensures messages are staged within the same database transaction as your domain changes, so no message is ever lost if the broker is unavailable at commit time. The IOutboxService&lt;TContext> stores events in an OutboxEvent table inside your DbContext transaction; a separate DeliveryHostedService picks them up and forwards them to the broker.
When to use Your command handler modifies domain state and must publish a message atomically You are replacing direct IEventBus.PublishAsync() calls from v8.5.0 You want to publish plain domain events without converting them to IntegrationEvent The delivery worker may run in a separate process or be added later Prerequisites Internal Messaging Setup — required for TransactionBehavior’s DbContext dependency injection.</description></item><item><title>Delivery Setup</title><link>https://juice-docs.creatorflow.io/core/messaging/delivery/index.html</link><pubDate>Thu, 19 Feb 2026 00:00:00 +0000</pubDate><guid>https://juice-docs.creatorflow.io/core/messaging/delivery/index.html</guid><description>Overview The Delivery setup registers DeliveryHostedService, a background worker that reads OutboxDelivery records from the database and forwards them to the broker transport (e.g., RabbitMQ). It operates independently of the outbox staging layer and can run in the same process or in a dedicated worker service.
When to use You have Outbox Setup configured and need a delivery worker You want to run the delivery worker in a separate process from the outbox-writing service You need retry backoff, stuck-message recovery, and a health check for the delivery backlog Prerequisites Outbox Setup — the OutboxEvent and OutboxDelivery tables must exist and be populated by IOutboxService&lt;TContext>.</description></item><item><title>Consumption Setup</title><link>https://juice-docs.creatorflow.io/core/messaging/consumption/index.html</link><pubDate>Thu, 19 Feb 2026 00:00:00 +0000</pubDate><guid>https://juice-docs.creatorflow.io/core/messaging/consumption/index.html</guid><description>Overview The Consumption setup registers a RabbitMQ consumer engine that deserializes incoming messages from a queue, routes them to the correct IIntegrationEventHandler&lt;T>, and automatically deduplicates re-delivered messages using IIdempotencyService — with no handler code changes required.
When to use Your service needs to receive integration events published by other services You want automatic idempotent event handling without writing deduplication logic in handlers You need dead-letter exchange (DLX) support for unhandled or failed messages Prerequisites Internal Messaging Setup — required for IIdempotencyService registration, which IntegrationEventDispatcher resolves at startup.</description></item><item><title>Full Pipeline Setup</title><link>https://juice-docs.creatorflow.io/core/messaging/full-setup/index.html</link><pubDate>Thu, 19 Feb 2026 00:00:00 +0000</pubDate><guid>https://juice-docs.creatorflow.io/core/messaging/full-setup/index.html</guid><description>Overview This guide combines all four messaging capabilities — internal MediatR idempotency, transactional outbox staging, background delivery, and RabbitMQ consumption — into a single, coherent services.AddMessaging() call. Follow this guide for new services or when you want the complete picture before choosing an incremental approach.
Prerequisites Either:
Complete the four individual setup guides (Internal Messaging, Outbox, Delivery, Consumption), OR Follow this guide from scratch NuGet packages Install all packages from the four setup guides:</description></item></channel></rss>